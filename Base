#define SDL_MAIN_HANDLED
#define SDL_TTF_H
#define _CRT_SECURE_NO_WARNINGS
#include <SDL.h>
#include <iostream>
#include <cmath>
#include <fstream>
#include <cstring>
#include <SDL_ttf.h>
#define NOMINMAX
#include <Windows.h>
#include <commdlg.h>
using namespace std;
//-lSDL2_ttf NU MERGEEEEEEEE
SDL_Texture* texturapiese[3];//self explenatory
//TTF_Font* font = TTF_OpenFont("C:\\Electron\\Movistar Text Regular.ttf", 20);
TTF_Font* font = TTF_OpenFont("C:/Windows/Fonts/arial.ttf", 24);
SDL_Rect saveButton, loadButton, sterge;
struct punct {
    float x, y;
};
struct piesa {
    int tip, ori, ori2, esteliber[3], b, nrLinii, nrpct, ar = -1, a, lin = -1, ce = -1, r = -1;
    float x, y, h, l, linie[20][4], arc[10][4], cerc[10][4], dr[10][4];
    punct conexiuni[3];
    char nume[200];

}p[100], ogp[100], ptmenu[100];
//pieces and originals we will use as base
struct conexiune {
    int p1, p2, tip, pin1, pin2;
}c[100];

int k = 1, l = 70, h = 70, x, y, t=1, k2 = 1, nrcol, moves, tipuripiese, moves2, clickMenu, ogk = 3, maxx, maxy, pm = 0, pmx = -1, pmy = -1, pml, pmh, movepm = 0, premovex, premovey;
int rot, rot2, mm = 1, running = 1, rpm, theme = 1, inbottommenu, selectbutton;
float scaleFactor = 50.0f;
int buttonWidth = 70;  // Dimensiunea fiecărui buton
int buttonHeight = 70;
int spacing = 10;       // Spațiere între butoane
int offsetX = 10;        // Poziția X inițială
int offsetY = 30, scrollmenuh=10;        // Poziția Y inițială
//TTF_Font* font = TTF_OpenFont("C:\Electron\Movistar Text Regular.ttf", 20);

//colors we will use, to be updated later with prettier ones
SDL_Color col[40] = {
    {15, 29, 46,255},
    {72, 192, 240,255},
    {38, 129, 199,255},
    {183, 207, 237, 255}, //col basic

    {15, 29, 46,255},
    {72, 192, 240,255},
    {38, 129, 199,255},
    {183, 207, 237, 255},// theme 1

    {21, 21, 23,255},
    {64, 61, 64,255},
    {58, 54, 58,255},
    {227, 222, 227, 255},//theme 2

    {59, 27, 49,255},
    {240, 72, 159,255},
    {191, 13, 93,255},
    {245, 201, 231, 255},//theme 3

    {43, 27, 26,255},
    {217, 97, 41,255},
    {133, 38, 25,255},
    {235, 191, 178, 255}, //theme 4

    {24, 54, 28,255},
    {201, 16, 32,255},
    {25, 125, 14,255},
    {247, 225, 225, 255}, //theme 5
};
void desenareLinie(SDL_Renderer* renderer, float x1, float y1, float x2, float y2, float scaleFactor) {
    SDL_RenderDrawLine(renderer, x1, y1, x2, y2);
}

void desenareCerc(SDL_Renderer* renderer, float cx, float cy, float rx, float ry, float scaleFactor) {
    for (int angle = 0; angle < 360; angle++) {
        float radian = angle * (3.14159 / 180);
        float x = cx + rx * cos(radian);
        float y = cy + ry * sin(radian);
        SDL_RenderDrawPoint(renderer, (int)(x), (int)(y));
    }
}

// Functie care deseneaza un arc cu partea goala spre dreapta
void desenareArc(SDL_Renderer* renderer, float x1, float y1, float x2, float y2) {
    // Raza cercului este jumătate din distanța dintre punctele de start și final
    float radius = (x2 - x1) / 2.0f;

    // Centrul cercului
    float cx = x1 + radius;
    float cy = y1; // Centrul pe linia orizontală Y

    // Unghiurile de început și de final (acoperim 180°)
    float startAngle = M_PI / 2.0f;     // 90 de grade (sus)
    float endAngle = 3 * M_PI / 2.0f;   // 270 de grade (jos)

    // Segmentare pentru desen (precum un arc împărțit în multe linii)
    const int segments = 100; // Mai multe segmente = arc mai lin
    float angleStep = (endAngle - startAngle) / segments;

    // Desenăm arcul segment cu segment
    for (int i = 0; i < segments; i++) {
        float angle1 = startAngle + i * angleStep;
        float angle2 = startAngle + (i + 1) * angleStep;

        // Puncte pe arc
        float xStart = cx + radius * cos(angle1);
        float yStart = cy - radius * sin(angle1);  // Y este inversat pentru a fi sus pe ecran
        float xEnd = cx + radius * cos(angle2);
        float yEnd = cy - radius * sin(angle2);    // Y inversat pentru sus pe ecran

        // Desenăm linia între punctele adiacente
        SDL_RenderDrawLine(renderer, (int)xStart, (int)yStart, (int)xEnd, (int)yEnd);
    }
}



void menu(SDL_Renderer* renderer) {
    clickMenu = 0; //cout << x << " " << y << endl;
    SDL_GetRendererOutputSize(renderer, &maxx, &maxy);
    //3 buttons for now each changing the piece we'll use
    if (x <= offsetX + buttonWidth + 10) {
        if (y <= tipuripiese * 80 - 10-scrollmenuh+10)
            t = (y - 10-scrollmenuh) / 80 + 1;
        l = ogp[t].l, h = ogp[t].h; //select base piece

        SDL_SetRenderDrawColor(renderer, col[t].r, col[t].g, col[t].b, col[t].a);
        clickMenu = 1;
        moves = 0;
    }
    else if (x <= offsetX + buttonWidth + 30) {
        if (offsetX > 0)offsetX = -80;
        else offsetX = 10;
        clickMenu = 1;
    }

    if (x>=130&&x<=230 && y >=maxy-120)
        moves = 1-moves, clickMenu = 1;
}

void text(SDL_Renderer* renderer, char t[100], int x, int y, int size) {
    TTF_Font* font = TTF_OpenFont("C:\\Electron\\Movistar Text Regular.ttf", size);
    SDL_Color color = { 255, 255, 255 };  // White



    const char* text = t;
    SDL_Surface* surface = TTF_RenderText_Solid(font, text, color);

    SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, surface);
    SDL_FreeSurface(surface);  // Free surface after creating texture


    SDL_Rect destRect = { x, y, strlen(t) * (size / 2), size * 2 };
    SDL_RenderCopy(renderer, texture, NULL, &destRect);
}

int inButton(int xb, int yb, int l, int h) {
    return x >= xb && x <= xb + l && y >= yb && y <= yb + h;
}

void drawMenu(SDL_Renderer* renderer) {
    int maxx, maxy;
    offsetY = scrollmenuh;
    char c2[] = "Save";
    char c1[] = "Load", c3[] = "Delete";
    SDL_GetRendererOutputSize(renderer, &maxx, &maxy);

    SDL_Rect bg = { 0, 0, offsetX + buttonWidth + 10 ,maxy };
    SDL_SetRenderDrawColor(renderer, col[0].r, col[0].g, col[0].b, col[0].a);
    SDL_RenderFillRect(renderer, &bg);
    SDL_Rect minimizer = { offsetX + buttonWidth + 10 , 0,  20, maxy };
    if (inButton(offsetX + buttonWidth + 10, 0, 20, maxy))
        SDL_SetRenderDrawColor(renderer, col[1].r, col[1].g, col[1].b, col[1].a);
    else
        SDL_SetRenderDrawColor(renderer, col[2].r, col[2].g, col[2].b, col[2].a);
    SDL_RenderFillRect(renderer, &minimizer);

    SDL_SetRenderDrawColor(renderer, col[0].r, col[0].g, col[0].b, col[0].a);
    SDL_RenderDrawLine(renderer, offsetX + buttonWidth + 30, 0, offsetX + buttonWidth + 30, maxy);
    int dir = (offsetX > 0) ? 1 : -1;
    for (int i = 0;i < 5;i++) {
        SDL_RenderDrawLine(renderer, offsetX + buttonWidth + 18 - 5 * dir + i, maxy / 2, offsetX + buttonWidth + 18 + 5 * dir + i, maxy / 2 - 30);
        SDL_RenderDrawLine(renderer, offsetX + buttonWidth + 18 - 5 * dir + i, maxy / 2, offsetX + buttonWidth + 18 + 5 * dir + i, maxy / 2 + 30);

    }

    int buttonTotalWidth = buttonWidth * 2 + spacing;  // Lățimea totală a celor două butoane + spațiu între ele
    int centerX = (maxx - buttonTotalWidth) / 2; // Poziția orizontală pentru butoane
    // Calculăm poziția Y pentru partea de jos a ferestrei
    int buttonY = maxy - (buttonHeight + 30);  // 30px distanță față de marginea de jos

    // Butonul Save
    saveButton = { centerX, buttonY, buttonWidth, buttonHeight };
    // Desenăm butonul Save
    loadButton = { centerX + buttonWidth + spacing, buttonY, buttonWidth, buttonHeight };
    sterge = { loadButton.x + buttonWidth + spacing, buttonY,buttonWidth,buttonHeight };
    if (inButton(centerX, buttonY, buttonWidth, buttonHeight))
        SDL_SetRenderDrawColor(renderer, col[1].r, col[1].g, col[1].b, col[1].a);
    else
        SDL_SetRenderDrawColor(renderer, col[2].r, col[2].g, col[2].b, col[2].a);
    SDL_RenderFillRect(renderer, &saveButton);
    SDL_SetRenderDrawColor(renderer, col[0].r, col[0].g, col[0].b, col[0].a);
    SDL_RenderDrawRect(renderer, &saveButton);
    text(renderer, c2, saveButton.x + (saveButton.w - strlen("Save") * (buttonHeight / 4)) / 2,
        saveButton.y + (saveButton.h - buttonHeight) / 2, buttonHeight / 2);  // Aliniere pe buton 


    if (inButton(centerX + buttonWidth + spacing, buttonY, buttonWidth, buttonHeight))
        SDL_SetRenderDrawColor(renderer, col[1].r, col[1].g, col[1].b, col[1].a);
    else
        SDL_SetRenderDrawColor(renderer, col[2].r, col[2].g, col[2].b, col[2].a);
    SDL_RenderFillRect(renderer, &loadButton);
    SDL_SetRenderDrawColor(renderer, col[0].r, col[0].g, col[0].b, col[0].a); // Contur negru
    SDL_RenderDrawRect(renderer, &loadButton);
    text(renderer, c1, loadButton.x + (loadButton.w - strlen("Load") * (buttonHeight / 4)) / 2,
        loadButton.y + (loadButton.h - buttonHeight) / 2, buttonHeight / 2);

    if (inButton(loadButton.x + buttonWidth + spacing, buttonY, buttonWidth, buttonHeight))
        SDL_SetRenderDrawColor(renderer, col[1].r, col[1].g, col[1].b, col[1].a);
    else
        SDL_SetRenderDrawColor(renderer, col[2].r, col[2].g, col[2].b, col[2].a);
    SDL_RenderFillRect(renderer, &sterge);
    SDL_SetRenderDrawColor(renderer, col[0].r, col[0].g, col[0].b, col[0].a);
    SDL_RenderDrawRect(renderer, &sterge);
    text(renderer, c3, sterge.x + (sterge.w - strlen("Delete") * (buttonHeight / 6)) / 2,
        sterge.y + (sterge.h - buttonHeight + 10), buttonHeight / 3);

    SDL_Rect moveMenurect = { 130, maxy - 120, 100, 100 };
    if (moves)
        SDL_SetRenderDrawColor(renderer, col[1].r, col[1].g, col[1].b, col[1].a);
    else
        SDL_SetRenderDrawColor(renderer, col[2].r, col[2].g, col[2].b, col[2].a);
    SDL_RenderFillRect(renderer, &moveMenurect);
    SDL_SetRenderDrawColor(renderer, col[0].r, col[0].g, col[0].b, col[0].a);
    SDL_RenderDrawRect(renderer, &moveMenurect);
    char c4[7] = "Move";
    text(renderer, c4, 130, maxy - 130, 50);

    for (int i = 1; i <= tipuripiese; i++) {
        // Definim zona pentru buton
        SDL_Rect buttonRect = { offsetX, offsetY, buttonWidth, buttonHeight };

        // Desenează fundalul butonului
        SDL_SetRenderDrawColor(renderer, col[1].r, col[1].g, col[1].b, col[1].a); // Gri deschis
        SDL_RenderFillRect(renderer, &buttonRect);
        if (x >= offsetX && x <= offsetX + buttonWidth && y >= offsetY && y <= offsetY + buttonHeight) {
            SDL_SetRenderDrawColor(renderer, col[3].r, col[3].g, col[3].b, col[3].a); // Gri deschis
            SDL_RenderFillRect(renderer, &buttonRect);
        }

        // Desenează conturul butonului
        SDL_SetRenderDrawColor(renderer, col[0].r, col[0].g, col[0].b, col[0].a); // Negru
        SDL_RenderDrawRect(renderer, &buttonRect);

        // Scalează coordonatele pieselor
        float usableWidth = buttonWidth * 0.8f;  // 80% din dimensiunea butonului
        float usableHeight = buttonHeight * 0.8f;
        float scaleX = usableWidth / 7.0f;     // Normalizăm la 200x200
        float scaleY = usableHeight / 7.0f;
        float scale = fmin(scaleX, scaleY);      // Păstrăm proporțiile
        float centerX = buttonRect.x + buttonWidth / 2.0f;
        float centerY = buttonRect.y + buttonHeight / 2.0f;

        // Desenează linii
        for (int j = 0; j <= ptmenu[i].lin; j++) {
            float x1 = centerX + ptmenu[i].linie[j][0] * scale;
            float y1 = centerY + ptmenu[i].linie[j][1] * scale;
            float x2 = centerX + ptmenu[i].linie[j][2] * scale;
            float y2 = centerY + ptmenu[i].linie[j][3] * scale;
            desenareLinie(renderer, x1, y1, x2, y2, 1.0f);
            //if (i == 1) cout <<endl <<j << " ";
        }

        // Desenează cercuri
        for (int j = 0; j <= ptmenu[i].ce; j++) {
            float cx = centerX + ptmenu[i].cerc[j][0] * scale;
            float cy = centerY + ptmenu[i].cerc[j][1] * scale;
            float radius = ptmenu[i].cerc[j][2] * scale;
            desenareCerc(renderer, cx, cy, radius, radius, 1.0f);
        }

        // Desenează dreptunghiuri
        for (int j = 0; j <= ptmenu[i].r; j++) {
            float x = centerX + ptmenu[i].dr[j][0] * scale;
            float y = centerY + ptmenu[i].dr[j][1] * scale;
            float w = ptmenu[i].dr[j][2] * scale;
            float h = ptmenu[i].dr[j][3] * scale;
            SDL_Rect rect = { (int)x, (int)y, (int)w, (int)h };
            SDL_RenderDrawRect(renderer, &rect);
        }

        // Desenează arcuri
        for (int j = 0; j <= ptmenu[i].ar; j++) {
            float cx = centerX + ptmenu[i].arc[j][0] * scale;
            float cy = centerY + ptmenu[i].arc[j][1] * scale;
            float r1 = ptmenu[i].arc[j][2] * scale;
            float r2 = ptmenu[i].arc[j][3] * scale;
            desenareArc(renderer, cx, cy, r1, r2);
        }

        // Avansează la următorul buton
        offsetY += buttonHeight + spacing;

    }
}
void drawPieceMenu(SDL_Renderer* renderer, int& pm) {
    if (pm) {
        if (pmx == -1 && pmy == -1)
            pmx = maxx - 250, pmy = maxy - 400, pml = 250, pmh = 400;

        SDL_SetRenderDrawColor(renderer, col[0].r, col[0].g, col[0].b, col[0].a);
        SDL_Rect menup = { pmx, pmy, pml, pmh };
        SDL_RenderFillRect(renderer, &menup);

        SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
        menup = { int(pmx + pml * 0.85), pmy, int(pml * 0.15), int(pml * 0.15) };
        //cout<<pmx<< " "<<pmy<< " "<<pmx+pml*0.9<< " "<<pmy+pmh*0.9<<endl;
        SDL_RenderFillRect(renderer, &menup);

        SDL_SetRenderDrawColor(renderer, col[2].r, col[2].g, col[2].b, col[2].a);
        menup = { pmx, pmy, int(pml * 0.85), int(pml * 0.15) };
        SDL_RenderFillRect(renderer, &menup);


        //va trb sa adaug text..alta librarie..

        char t[100] = "Piesa ";
        t[strlen(t)] = char(pm + '0');
        text(renderer, t, pmx, pmy, 20);

        strcpy(t, "Tip: ");
        strcat(t, ptmenu[p[pm].tip].nume);
        text(renderer, t, pmx, pmy + 50, 20);
        int ch=0;

        //for (int i = 0; i < ptmenu[j].nrpct; ++i)
          //  if (piesa.esteliber[i] == 0) {
        for (int i = 0;i < ptmenu[p[pm].tip].nrpct; i++) {
            sprintf(t, "Conexiunea %d: %s", i + 1, (p[pm].esteliber[i] == 0) ? "Liber" : "Ocupat");
            ch = pmy + 50 * (i + 2); //current heigth
            text(renderer, t, pmx, ch, 20);
            //cout << p[pm].esteliber[i] << " ";
        }
        ch += 50;
        strcpy(t, "Marime:");
        text(renderer, t, pmx, ch, 20);
        //de adaugat mami tarziu mam plictisit

        //cout << endl;
    }
}

int inPieceMenu() {
    if (x >= pmx && x <= pmx + pml && y >= pmy && y <= pmy + pmh) {
        if (x >= int(pmx + pml * 0.85) && y <= int(pmy + pml * 0.15))
            pm = 0;
        else if (x<int(pmx + pml * 0.85) && y <= int(pmy + pmh * 0.15))
            movepm = 1;
        else movepm = 0;
        cout << movepm;
        return 1;
    }
    return 0;
}

void drawConnectionPoints(SDL_Renderer* renderer, piesa& piesa) {
    // Setează culoarea mov pentru dreptunghiuri
    SDL_SetRenderDrawColor(renderer, col[1].r, col[1].g, col[1].b, col[1].a); // Mov
    int j = piesa.tip;
    // Desenăm dreptunghiuri la punctele de conexiune
    for (int i = 0; i < ptmenu[j].nrpct; ++i)
        if (piesa.esteliber[i] == 0) {

            float pointX = piesa.x + piesa.conexiuni[i].x * 15 + 2;
            float pointY = piesa.y + piesa.conexiuni[i].y * 15 + 3;


            SDL_Rect rect = { pointX - piesa.l / 8.75, pointY - piesa.h / 8.75, piesa.l / 8.75, piesa.h / 8.75 }; // Ajustăm pentru a plasa punctul în mijloc
            SDL_RenderFillRect(renderer, &rect);


        }
}

void drawPiece(SDL_Renderer* renderer, int i) {

    //piese inserate
    SDL_Rect rect = { p[i].x - p[i].l / 2,p[i].y - p[i].h / 2,p[i].l,p[i].h };
    if (p[i].a == 0)
    {
        SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
        SDL_RenderFillRect(renderer, &rect);
    }
    else
    {
        SDL_SetRenderDrawColor(renderer, col[0].r, col[0].g, col[0].b, col[0].a); // Negru
        int  scale = 15;

        // Desenează linii
        for (int j = 0; j <= p[i].lin; j++) {

            float x1 = p[i].x + p[i].linie[j][0] * scale;
            float y1 = p[i].y + p[i].linie[j][1] * scale;
            float x2 = p[i].x + p[i].linie[j][2] * scale;
            float y2 = p[i].y + p[i].linie[j][3] * scale;
            desenareLinie(renderer, x1, y1, x2, y2, 1.0f);
            //if (i == 1) cout <<endl <<j << " ";
        }

        // Desenează cercuri
        for (int j = 0; j <= p[i].ce; j++) {
            float cx = p[i].x + p[i].cerc[j][0] * scale;
            float cy = p[i].y + p[i].cerc[j][1] * scale;
            float radius = p[i].cerc[j][2] * scale;
            desenareCerc(renderer, cx, cy, radius, radius, 1.0f);
        }

        // Desenează dreptunghiuri
        for (int j = 0; j <= p[i].r; j++) {
            float x = p[i].x + p[i].dr[j][0] * scale;
            float y1 = p[i].y + p[i].dr[j][1] * scale;
            float w = p[i].dr[j][2] * scale;
            float h = p[i].dr[j][3] * scale;
            SDL_Rect rect = { (int)x, (int)y1, (int)w, (int)h };
            SDL_RenderDrawRect(renderer, &rect);
        }



        drawConnectionPoints(renderer, p[i]);
    }




}
void citestePiese()
{
    int i, j;
    char c = 0;
    ifstream f("C:\\Electron.txt");
    if (!f.is_open()) {
        cout << "Nu s-a putut deschide fișierul!" << endl;

    }
    f >> tipuripiese;
    f.ignore(numeric_limits<streamsize>::max(), '\n');
    for (i = 1;i <= tipuripiese;i++)
    {

        f.get(ptmenu[i].nume, 200);
        f.ignore(numeric_limits<streamsize>::max(), '\n');
        f >> ptmenu[i].nrpct;
        f.ignore(numeric_limits<streamsize>::max(), '\n');
        for (j = 0;j < ptmenu[i].nrpct;j++)
        {
            f >> ptmenu[i].conexiuni[j].x >> ptmenu[i].conexiuni[j].y;
            f.ignore(numeric_limits<streamsize>::max(), '\n');

        }
        f >> ptmenu[i].nrLinii;
        f.ignore(numeric_limits<streamsize>::max(), '\n');
        for (j = 0;j < ptmenu[i].nrLinii;j++) {
            int k;
            f >> c;
            if (c == 'A')
            {
                ++ptmenu[i].ar;
                for (k = 0;k < 4;k++)
                    f >> ptmenu[i].arc[ptmenu[i].ar][k];
            }
            else if (c == 'L')
            {
                ++ptmenu[i].lin;  for (k = 0;k < 4;k++)
                    f >> ptmenu[i].linie[ptmenu[i].lin][k];
            }
            else if (c == 'O')
            {
                ++ptmenu[i].ce;
                for (k = 0;k < 4;k++)
                    f >> ptmenu[i].cerc[ptmenu[i].ce][k];
            }
            else if (c == 'R')
            {
                ++ptmenu[i].r;
                for (k = 0;k < 4;k++)
                    f >> ptmenu[i].dr[ptmenu[i].r][k];
            }
            f.ignore(numeric_limits<streamsize>::max(), '\n');

        }
        ogp[i] = ptmenu[i];
        ogp[i].l = ogp[i].h = 70;

    }

    f.close();



}
void createPiece(SDL_Renderer* renderer) {
    int i;
    p[k] = ogp[t];
    //p[k].nrLinii = ptmenu[t].nrLinii;
    p[k].x = x, p[k].y = y;
    p[k].l = 70, p[k].h = 70, p[k].tip = t;

    p[k++].ori = 0;
    for (i = 0;i < 3;i++)
        p[k - 1].esteliber[i] = 0;
    p[k - 1].a = p[k - 1].b = 1;
    drawPiece(renderer, k - 1);


}

void deleteConnection(int i, int x, int pin) {
    cout << "jezz" << i;
    p[x].esteliber[pin]--;

    for (int j2 = i;j2 < k2;j2++)
        c[j2] = c[j2 + 1];

    k2--;
}

void deletePiece(int i) {
    int j;
    for (j = 1;j <= k2;j++)
    {
        if (c[j].p1 == i) {
            deleteConnection(j, c[j].p2, c[j].pin2);

            j--;
        }
        if (c[j].p2 == i)
        {
            deleteConnection(j, c[j].p1, c[j].pin1);
            j--;
        }


    }
    for (j = 1; j <= k2; ++j) {
        if (c[j].p1 > i) c[j].p1--;
        if (c[j].p2 > i) c[j].p2--;
    }
    for (j = i;j < k;j++)
        p[j] = p[j + 1];
    k--;



}

int inPiece() {

    //return which piece was clicked, 0 if no piece
    for (int i = 0;i < k;i++) {

        if (x > p[i].x - p[i].l / 2 && x < p[i].x + p[i].l / 2)
        {

            if (y > p[i].y - p[i].h / 2 && y < p[i].y + p[i].h / 2)
                return i;
        }
    }
    return 0;
}
void rotateValue(float& x, float& y, float cx, float cy, float angle) {

    float radians = angle * M_PI / 180.0f;

    float newx = cos(radians) * (x - 0) - sin(radians) * (y - 0);
    float newy = sin(radians) * (x - 0) + cos(radians) * (y - 0);

    x = newx;
    y = newy;
}

int rotateCheck(int i) {
    if (rot == 0)
        return 0;
    int cx, cy;

    cx = p[i].x + (p[i].l + 15) * cos((p[i].ori2 - 60) * M_PI / 180.0);
    cy = p[i].y + (p[i].l + 15) * sin((p[i].ori2 - 60) * M_PI / 180.0);
    //cout << cx << " " << cy << endl;
    if ((x - cx) * (x - cx) + (y - cy) * (y - cy) <= p[i].l / 10* p[i].l / 10) {
        return 1;
    }
    return 0;
}

void rotatePiece(SDL_Renderer* renderer, int i) {
    if (rot) {
        //cout << rot2  <<" " <<rotateCheck(i)<< endl;
        SDL_SetRenderDrawColor(renderer, col[0].r, col[0].g, col[0].b, col[0].a);

        desenareCerc(renderer, p[i].x, p[i].y, p[i].l + 15, p[i].l + 15, 1);

        //p[i].ori= p[i].ori2;
        //p[i].ori2= (atan2(y - p[i].y, x - p[i].x)+45) * 180.0 / M_PI;
        //cout << angle << " " << angle2 << endl;
        //angle = angle2 - angle;
        //p[i].ori = angle - p[i].ori;
        //cout << angle << " "<< angle2 << endl;
        //cout << endl;
        desenareCerc(renderer, p[i].x + (p[i].l + 15) * cos((p[i].ori2 - 60) * M_PI / 180.0), p[i].y + (p[i].l + 15) * sin((p[i].ori2 - 60) * M_PI / 180.0), p[i].l/7, p[i].l / 7, 1);

        rotateCheck(i);
        if (rot2) {
            p[i].ori = p[i].ori2;
            p[i].ori2 = (atan2(y - p[i].y, x - p[i].x) + 45) * 180.0 / M_PI;

            for (int j = 0; j < ptmenu[p[i].tip].nrLinii; j++) {
                //cout << p[i].linie[j][0] << " " << p[i].linie[j][1] << " " << p[i].linie[j][2] << " " << p[i].linie[j][3] << endl;
                rotateValue(p[i].linie[j][0], p[i].linie[j][1], p[i].x, p[i].y, p[i].ori2 - p[i].ori);
                rotateValue(p[i].linie[j][2], p[i].linie[j][3], p[i].x, p[i].y, p[i].ori2 - p[i].ori);
            }
            for (int j = 0;j < p[i].nrpct;j++) {
                rotateValue(p[i].conexiuni[j].x, p[i].conexiuni[j].y, p[i].x, p[i].y, p[i].ori2 - p[i].ori);
            }
        }
    }
}
/*void rotationSnap(int i, int factor) {
    not sure if its worth fixing cand avem deja 360 grade
    //p[i].ori = int(p[i].ori2 / 90+factor) * 90;
    cout << p[i].ori << " " << p[i].ori2 << endl;

    for (int j = 0; j < ptmenu[p[i].tip].nrLinii; j++)
        for(int k=0;k<4;k++){
            //cout << p[i].linie[j][0] << " " << p[i].linie[j][1] << " " << p[i].linie[j][2] << " " << p[i].linie[j][3] << endl;
            p[i].linie[j][k] = ogp[p[i].tip].linie[j][k];
         }
    for (int j = 0;j < p[i].nrpct;j++) {
        p[i].conexiuni[j] = ogp[i].conexiuni[j];
    }
    //p[i].ori2 = p[i].ori + factor;
}*/



void movePiece(SDL_Renderer* renderer, SDL_Event event) {
    c[k2].p2 = 0;
    SDL_GetMouseState(&x, &y);
    int i = inPiece(), ok = 1, j;
    p[inPiece()].x += event.motion.xrel; // moves position
    p[inPiece()].y += event.motion.yrel;
    for (j = 1;j <= k && ok;j++)
        if (abs(p[j].x - p[i].x) < (p[j].l + p[i].l) / 2 && abs(p[j].y - p[i].y) < (p[j].l + p[i].l) / 2 && i != j)
        {
            p[i].a = 0;
            p[i].b = j;
            ok = 0;
        }
    if (ok)
    {
        p[i].a = 1;
        p[p[i].b].a = 1;
    }
}


void movePieceMenu(SDL_Renderer* renderer, SDL_Event event) {
    c[k2].p2 = 0;
    SDL_GetMouseState(&x, &y);

    pmx += event.motion.xrel; // moves position
    pmy += event.motion.yrel;
    //cout<<pmx<< " "<<pmy<<endl;
}

int inPunct(float mouseX, float mouseY, int& piesaselectata, int& pinselectat) {
    int i;
    for (i = 0;i < k;i++)
        for (int j = 0; j < ptmenu[p[i].tip].nrpct; j++) {

            float pointX = p[i].x + p[i].conexiuni[j].x * 15;
            float pointY = p[i].y + p[i].conexiuni[j].y * 15;
            float size = p[i].l / 5; // marimea punctului

            //  mouse ul este peste punct
            if (mouseX >= pointX - size && mouseX <= pointX + size &&
                mouseY >= pointY - size && mouseY <= pointY + size) {
                piesaselectata = i;
                pinselectat = j;
                return 1;
            }

        }

    return 0;
}
int sourcePiece = -1, targetPiece = -1, sourcePin = -1, targetPin = -1;

void dirVector(int& a, int& b) {
    //saves most important direction
    //if its more to the right than up then it will be right etc
    if (abs(a) > abs(b)) {
        a = (a > 0) - (a < 0);
        b = 0;
    }
    else {
        b = (b > 0) - (b < 0);
        a = 0;
    }
}

void drawConnect(SDL_Renderer* renderer, int i) {
    //black line between 2 pieces, to be changed later
    SDL_SetRenderDrawColor(renderer, col[0].r, col[0].g, col[0].b, col[0].a);
    //SDL_RenderDrawLine(renderer, p[c[i].p1].conexiuni[c[i].pin1].x + p[c[i].p1].x - p[c[i].p1].l / 2, p[c[i].p1].conexiuni[c[i].pin1].y + p[c[i].p1].y - p[c[i].p1].h / 2,
        //p[c[i].p2].conexiuni[c[i].pin2].x +p[c[i].p2].x -p[c[i].p2].l / 2, p[c[i].p2].conexiuni[c[i].pin2].y+p[c[i].p2].y - p[c[i].p2].h / 2);
    int x1 = p[c[i].p1].conexiuni[c[i].pin1].x * 15 + p[c[i].p1].x;// -p[c[i].p1].l / 2 - p[c[i].p1].l / 17;
    int y1 = p[c[i].p1].conexiuni[c[i].pin1].y * 15 + p[c[i].p1].y;// -p[c[i].p1].h / 2 - p[c[i].p1].h / 17;
    int x2 = p[c[i].p2].conexiuni[c[i].pin2].x * 15 + p[c[i].p2].x;// -p[c[i].p2].l / 2 - p[c[i].p1].l / 17;
    int y2 = p[c[i].p2].conexiuni[c[i].pin2].y * 15 + p[c[i].p2].y;// -p[c[i].p2].h / 2 - p[c[i].p1].h / 17;
    //cout << x1 << ' ' << y1 << " " << x2 << " " << y2 << endl;
    int leftright1, updown1, leftright2, updown2, lc;

    lc = abs(x2 - x1) / 3 + 10;

    //1 if right/up -1 if left/down
    leftright1 = x1 - p[c[i].p1].x;
    updown1 = y1 - p[c[i].p1].y;
    dirVector(leftright1, updown1);

    //small line to continue the direction
    SDL_RenderDrawLine(renderer, x1, y1, x1 + leftright1 * lc, y1 + updown1 * lc);
    x1 = x1 + leftright1 * lc, y1 = y1 + updown1 * lc; //updates where we are


    //same for second one
    leftright2 = x2 - p[c[i].p2].x;
    updown2 = y2 - p[c[i].p2].y;
    dirVector(leftright2, updown2);

    SDL_RenderDrawLine(renderer, x2, y2, x2 + leftright2 * lc, y2 + updown2 * lc);
    x2 = x2 + leftright2 * lc, y2 = y2 + updown2 * lc;
    //cout<<x1<< " "<<y1<< " "<<x2<< " "<<y2<<leftright1<< " "<<updown2<<endl;
    //390 214 267 3451 -1
    //787 416 609 439 1 0 -1 1
    if (leftright2 && leftright2 == -updown1 || (leftright1 == -leftright2 && leftright1 == -1) || x1 > x2)
        swap(x1, x2), swap(y1, y2), swap(leftright1, leftright2), swap(updown1, updown2);
    if (leftright1 == -1 && leftright1 == -updown2 && x1 < x2) {
        SDL_RenderDrawLine(renderer, x1, y1, x1, max(y2, y1 + lc));
        y1 = max(y2, y1 + lc);
    }
    if (leftright1 == 1 && leftright1 == -updown2 && x1 > x2 && y2 >= y1) {
        //SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
        SDL_RenderDrawLine(renderer, x1, y1, x1, max(y2, y1 + lc));
        y1 = max(y2, y1 + lc);
    }
    if (updown1 == 1 && updown1 == leftright2 && x1 > x2) {
        SDL_RenderDrawLine(renderer, x2, y2, x2, max(y1, y2 + lc));
        y2 = max(y1, y2 + lc);
        //cout<<x1<< " "<<y1<< " "<<x2<< " "<<y2<<leftright1<< " "<<updown2<<endl;
    }
    //cout<<x1<< " "<<y1<< " "<<x2<< " "<<y2<<leftright1<< " "<<updown2<<endl;
    if (updown2 == -1 && updown2 == leftright1 && y2 < y1) {
        SDL_RenderDrawLine(renderer, x1, y1, x1, y1 + lc);
        y1 = y1 + lc;
        //cout<<x1<< " "<<y1<< " "<<x2<< " "<<y2<<" "<<leftright1<< " "<<updown2<<endl;
    }

    //SDL_SetRenderDrawColor(renderer, 0, 255, 0, 255);
    if (updown1 != 0) {
        int aux;
        if (updown1 == 1) {
            aux = max(y1, y2);
        }
        else aux = min(y1, y2);
        SDL_RenderDrawLine(renderer, x1, y1, x1, aux);
        y1 = aux; //so that we get a rounder form if both are vertical
        SDL_RenderDrawLine(renderer, x1, y1, x1 + (x2 - x1) / 4, y1);
        x1 = x1 + (x2 - x1) / 4;
        leftright1 = -leftright2; //so that we get a less harsh connection if one is vertical the other horizontal
    }
    //same for second
    if (updown2 != 0) {
        int aux;
        if (updown2 == 1) {
            aux = max(y1, y2);
        }
        else aux = min(y1, y2);
        SDL_RenderDrawLine(renderer, x2, y2, x2, aux);
        y2 = aux;
        SDL_RenderDrawLine(renderer, x2, y2, x2 + (x1 - x2) / 4, y2);
        x2 = x2 + (x1 - x2) / 4;
        leftright2 = -leftright1;//working primarily horizontally
    }
    //SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    //cadranu 3 reparat
    if ((x1 > x2 && leftright2 == -1) || (x1 < x2 && leftright2 == 1) || updown1 == leftright2)
        swap(x1, x2), swap(y1, y2), swap(leftright1, leftright2), swap(updown1, updown2);
    //so we'll need less cases as x1 is the smaller one

    //SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
    //787 416 609 439 1 0 -1 1
    if (leftright1 * leftright2 < 0 && leftright1 == -1 && !updown2) {
        SDL_RenderDrawLine(renderer, x2, y2, x2, min(y2 - lc / 2, (y1 + y2 / 2)));
        y2 = min(y2 - lc / 2, (y1 + y2 / 2));
    }
    //SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);

    //cout<<x1<< " "<<y1<< " "<<x2<< " "<<y2<<" "<<leftright1<< " "<<updown1<< " "<<leftright2<< " "<<updown2<<endl;

    //750 274 566 338 1 0 -1 1
    //SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
    if (leftright1 * leftright2<0 && leftright2 == -1 && !updown1 && x1>x2) {
        //swap(x1, x2), swap(y1, y2), swap(leftright1, leftright2), swap(updown1, updown2);
        SDL_RenderDrawLine(renderer, x1, y1, x1, max((y1 + y2) / 2, y1 + lc / 2));
        y1 = max((y1 + y2) / 2, y1 + lc / 2);
        swap(x1, x2), swap(y1, y2), swap(leftright1, leftright2), swap(updown1, updown2);
    }
    //SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);

    //for the cases in which theyre going in opposite directions
    if (updown1 * updown2 < 0) {
        SDL_RenderDrawLine(renderer, x2, y2, x2 + (x1 - x2) / 3, y2);
        x2 = x2 + (x1 - x2) / 3;
    }
    //SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    //idk if the if else is necessary tbh
    if (x1 > x2 && leftright1 == updown2 == -1)
        swap(x1, x2), swap(y1, y2), swap(leftright1, leftright2), swap(updown1, updown2);
    if (updown1 && updown2) {
        SDL_RenderDrawLine(renderer, x1, y1, x2, y1);
        SDL_RenderDrawLine(renderer, x2, y1, x2, y2);
    }
    else {
        SDL_RenderDrawLine(renderer, x1, y1, x1, y2);
        SDL_RenderDrawLine(renderer, x1, y2, x2, y2);
    }
}
void connect(SDL_Renderer* renderer) {

    // Găsește piesa și pinul sursă
    if (targetPiece != -1 && targetPiece != sourcePiece || sourcePiece == -1) {
        sourcePiece = -1, targetPiece = -1, sourcePin = -1, targetPin = -1;

        if (!inPunct(x, y, sourcePiece, sourcePin)) {
            cout << "Nu s-a selectat un punct valid pentru conexiune." << endl;
            return;
        }
    }


    // Găsește piesa și pinul destinație
    if (!inPunct(x, y, targetPiece, targetPin) || sourcePiece == targetPiece) {
        cout << "Nu se poate realiza conexiunea." << sourcePiece << " " << targetPiece << endl;
        return;
    }



    // Creează conexiunea
    c[k2] = { sourcePiece, targetPiece, 0, sourcePin, targetPin };
    p[sourcePiece].esteliber[sourcePin]++;
    p[targetPiece].esteliber[targetPin]++;

    drawConnect(renderer, k2);

    k2++;

    cout << "Conexiune realizată între piesa " << sourcePiece << " și " << targetPiece << "." << endl;


}
void resizePiece(piesa& p, float factor) {
    p.l += factor * p.l;
    p.h += factor * p.h;
    for (int j = 0;j < p.nrLinii;j++) {
        p.linie[j][0] += factor * p.linie[j][0];
        p.linie[j][1] += factor * p.linie[j][1];
        p.linie[j][2] += factor * p.linie[j][2];
        p.linie[j][3] += factor * p.linie[j][3];

        p.arc[j][2] += factor * p.arc[j][2];
        p.arc[j][3] += factor * p.arc[j][3];

        p.cerc[j][2] += factor * p.cerc[j][2];
        p.cerc[j][3] += factor * p.cerc[j][3];

    }
    for (int j = 0;j < p.nrpct;j++) {
        p.conexiuni[j].x += factor * p.conexiuni[j].x;
        p.conexiuni[j].y += factor * p.conexiuni[j].y;
    }
}
void resizePM(SDL_Renderer* renderer, int i) {
    if (rpm) {
        SDL_SetRenderDrawColor(renderer, col[2].r, col[2].g, col[2].b, col[2].a);
        desenareCerc(renderer, p[i].x - p[i].l / 1, p[i].y + p[i].h * 1.4, p[i].l / 4, p[i].l / 4, 1);
        desenareCerc(renderer, p[i].x + p[i].l / 1, p[i].y + p[i].h * 1.4, p[i].l / 4, p[i].l / 4, 1);

        for (int j = 0;j < 3;j++) {
            SDL_RenderDrawLine(renderer, p[i].x - p[i].l / 1.13, p[i].y + p[i].h * 1.4 + j - 2, p[i].x - p[i].l / 0.9, p[i].y + p[i].h * 1.4 + j - 2);
            SDL_RenderDrawLine(renderer, p[i].x + p[i].l / 1.13, p[i].y + p[i].h * 1.4 + j - 2, p[i].x + p[i].l / 0.9, p[i].y + p[i].h * 1.4 + j - 2);
            SDL_RenderDrawLine(renderer, p[i].x + p[i].l / 1 + j - 2, p[i].y + p[i].h * 1.28, p[i].x + p[i].l / 1 + j - 2, p[i].y + p[i].h * 1.5);
        }

    }
}
int resizeCheck(int i) {
    if ((x - (p[i].x - p[i].l / 1)) * (x - (p[i].x - p[i].l / 1)) +
        (y - (p[i].y + p[i].h * 1.4)) * (y - (p[i].y + p[i].h * 1.4)) <=
        (p[i].l / 4) * (p[i].l / 4)) {
        return -1;
    }

    else if ((x - (p[i].x + p[i].l / 1)) * (x - (p[i].x + p[i].l / 1)) +
        (y - (p[i].y + p[i].h * 1.4)) * (y - (p[i].y + p[i].h * 1.4)) <=
        (p[i].l / 4) * (p[i].l / 4)) {
        return 1;
    }

    return 0;
}

void moveScreen(SDL_Renderer* render, SDL_Event event) {
    SDL_GetMouseState(&x, &y);
    int i;
    for (i = 1;i < k;i++) {
        p[i].x += event.motion.xrel; // moves position
        p[i].y += event.motion.yrel;
    }
}

void zoomScreen(SDL_Renderer* renderer, float factor) {
    SDL_GetMouseState(&x, &y);
    int i;
    for (i = 1;i < k;i++) {
        resizePiece(p[i], factor);
        p[i].x += (p[i].x - x) * factor; // moves position
        p[i].y += (p[i].y - y) * factor;
        //p[i].l += p[i].l * zoom;
        //p[i].h += p[i].h * zoom;
    }
    for (i = 1;i <= tipuripiese;i++) {
        resizePiece(ogp[i], factor);
    }
    cout << ogp[0].l;
}

void themeChangeArrow(SDL_Renderer* renderer, int y, int h) {
    SDL_SetRenderDrawColor(renderer, col[2].r, col[2].g, col[2].b, col[2].a);
    y += 10;
    h *= 0.75;
    for (int i = 0;i < 10;i++) {
        SDL_RenderDrawLine(renderer, maxx / 2 - maxx / 6 + i, y, maxx / 2 - maxx / 6 - maxx / 20 + i, y + h / 2);
        SDL_RenderDrawLine(renderer, maxx / 2 - maxx / 6 + i, y + h, maxx / 2 - maxx / 6 - maxx / 20 + i, y + h / 2);

        SDL_RenderDrawLine(renderer, maxx / 2 + maxx / 6 + i, y, maxx / 2 + maxx / 6 + maxx / 20 + i, y + h / 2);
        SDL_RenderDrawLine(renderer, maxx / 2 + maxx / 6 + i, y + h, maxx / 2 + maxx / 6 + maxx / 20 + i, y + h / 2);
    }
}
void themeChange(int i) {
    col[0] = col[4 * i];
    col[1] = col[4 * i + 1];
    col[2] = col[4 * i + 2];
    col[3] = col[4 * i + 3];
}

void gradient(SDL_Renderer* renderer, SDL_Color c, int x, int y, int l, int h, int stdr, int tp) {
    float segm = 255.0 / l;
    float taper = float(h) / float(l) / 2.0 * tp;
    float percent;
    for (int i = 0;i <= l;i++) {
        //cout << i << " ";
        //cout << c.a - segm * i << " ";
        percent = float(i) / float(l);
        SDL_SetRenderDrawColor(renderer, c.r, c.g, c.b, c.a - segm * i);
        SDL_RenderDrawLine(renderer, x + stdr * i, y + i * taper * percent * percent, x + stdr * i, y + h - i * taper * percent * percent);
    }
}
SDL_Color highlightSelection(int yMM, int h) {
    if (y >= yMM && y <= yMM + h) {
        return col[1];
    }
    else return col[2];
}
void buttonMain(SDL_Renderer* renderer, SDL_Color c, int x, int y, int l, int h) {
    SDL_Rect button = { x - l / 2, y, l, h };
    c = highlightSelection(y, h);
    SDL_SetRenderDrawColor(renderer, c.r, c.g, c.b, c.a);
    SDL_RenderFillRect(renderer, &button);

    gradient(renderer, c, x + l / 2, y, l, h - 1, 1, 0);
    gradient(renderer, c, x - l / 2, y, l, h - 1, -1, 0);

}

void load();

void mainMenu(SDL_Renderer* renderer, SDL_Event event) {

    SDL_SetRenderDrawColor(renderer, col[0].r, col[0].g, col[0].b, col[0].a);
    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);

    SDL_RenderClear(renderer);
    char t[100];
    strcpy(t, "Electron");
    SDL_GetRendererOutputSize(renderer, &maxx, &maxy);
    int size = 80;

    text(renderer, t, maxx / 2 - strlen(t) / 2.0 * size / 2, maxy / 2 - size * 4, size);

    buttonMain(renderer, col[1], maxx / 2, maxy / 3, maxx / 3, maxy / 5);
    /*SDL_Rect button = {maxx / 3, maxy / 3, maxx / 3, maxy / 5};
    SDL_SetRenderDrawColor(renderer, col[1].r, col[1].g, col[1].b, col[1].a);
    SDL_RenderFillRect(renderer, &button);

    gradient(renderer, col[1], maxx / 3 * 2, maxy / 3, maxx / 4, maxy / 5-1, 1, 0);
    gradient(renderer, col[1], maxx / 3, maxy / 3, maxx / 4, maxy / 5 - 1, -1, 0);*/

    strcpy(t, "Start");
    size = 60;
    text(renderer, t, maxx / 2 - strlen(t) / 2 * size / 2 - 10, maxy / 2.8, size);

    buttonMain(renderer, col[2], maxx / 2, maxy / 1.72, maxx / 6, maxy / 12);
    strcpy(t, "Load");
    size = 40;
    text(renderer, t, maxx / 2 - strlen(t) / 2.0 * size / 2, maxy / 1.75, size);

    buttonMain(renderer, col[2], maxx / 2, maxy / 1.72 + maxy / 10, maxx / 6, maxy / 12);
    strcpy(t, "Theme");
    size = 40;
    text(renderer, t, maxx / 2 - strlen(t) / 2.0 * size / 2, maxy / 1.75 + maxy / 10, size);
    themeChangeArrow(renderer, maxy / 1.72 + maxy / 10, maxy / 12);

    buttonMain(renderer, col[2], maxx / 2, maxy / 1.72 + 2 * maxy / 10, maxx / 6, maxy / 12);
    strcpy(t, "Exit");
    size = 40;
    text(renderer, t, maxx / 2 - strlen(t) / 2.0 * size / 2, maxy / 1.75 + 2 * maxy / 10, size);

    if (event.type == SDL_MOUSEBUTTONDOWN) {
        if (y >= maxy / 3 && y <= maxy / 3 + maxy / 5)
            mm = 0;
        else if (y >= maxy / 1.72 && y <= maxy / 1.72 + maxy / 12) {
            load();
            mm = 0;
        }
        else if (y >= maxy / 1.72 + 2 * maxy / 10 && y <= maxy / 1.72 + 2 * maxy / 10 + maxy / 12) {
            mm = 0;
            running = 0;
        }
        else if (y >= maxy / 1.72 + maxy / 10 && y <= maxy / 1.72 + maxy / 10 + maxy / 12) {
            cout << theme;
            if (x < maxx / 2) {
                theme--;
                if (theme < 1) theme = 5;
            }
            else {
                theme++;
                if (theme > 5) theme = 1;
            }
            cout << theme;
            themeChange(theme);
        }
    }
    if (event.type == SDL_KEYDOWN && event.key.keysym.sym == SDLK_RETURN) {
        mm = 0;
    }

    if (event.type == SDL_QUIT) {
        mm = 0, running = 0;
    }
    SDL_RenderPresent(renderer);
}



void drawLine(SDL_Renderer* renderer) {
    //no use for testing only
    SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
    SDL_RenderDrawLine(renderer, 200, 100, 700, 500);
}


void redrawAll(SDL_Renderer* renderer) {
    int i;
    SDL_SetRenderDrawColor(renderer, col[3].r, col[3].g, col[3].b, col[3].a);
    SDL_RenderClear(renderer);
    //drawMenu(renderer);
    for (i = 1;i < k;i++) {
        drawPiece(renderer, i);
    }
    for (i = 1;i < k2;i++) {
        drawConnect(renderer, i);
    }

    rotatePiece(renderer, rot);
    resizePM(renderer, rpm);
    drawMenu(renderer);
    drawPieceMenu(renderer, pm);
    SDL_RenderPresent(renderer);
}


void deleteAll() {
    k = 1; k2 = 1;
    rot = 0, rpm = 0;
}
void save() {
    OPENFILENAME ofn;
    wchar_t szFile[260];

    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = NULL;
    ofn.lpstrFile = szFile;
    ofn.lpstrFile[0] = L'\0';
    ofn.nMaxFile = sizeof(szFile) / sizeof(wchar_t);
    ofn.lpstrFilter = L"All Files\0*.*\0Text Files\0*.TXT\0";
    ofn.nFilterIndex = 1;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = L"C:\\";
    ofn.lpstrTitle = L"Save As";
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_OVERWRITEPROMPT;

    if (GetSaveFileName(&ofn) == TRUE) {
        wcout << L"Fișier salvat ca: " << szFile << endl;

        ofstream outFile(szFile, ios::binary);
        if (!outFile) {
            cerr << "Eroare la deschiderea fișierului pentru salvare!" << endl;
            return;
        }

        // Salvează numărul de piese și conexiuni
        outFile.write(reinterpret_cast<char*>(&k), sizeof(k));  // Numărul de piese
        outFile.write(reinterpret_cast<char*>(&k2), sizeof(k2)); // Numărul de conexiuni

        // Salvează piesele și conexiunile
        outFile.write(reinterpret_cast<char*>(p), k * sizeof(piesa));        // Tabloul `p`
        outFile.write(reinterpret_cast<char*>(c), k2 * sizeof(conexiune));  // Tabloul `c`

        outFile.close();
    }
}
void load() {
    OPENFILENAME ofn;
    wchar_t szFile[260];

    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = NULL;
    ofn.lpstrFile = szFile;
    ofn.lpstrFile[0] = L'\0';
    ofn.nMaxFile = sizeof(szFile) / sizeof(wchar_t);
    ofn.lpstrFilter = L"All Files\0*.*\0Text Files\0*.TXT\0";
    ofn.nFilterIndex = 1;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = L"C:\\";
    ofn.lpstrTitle = L"Open File";
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;

    if (GetOpenFileName(&ofn) == TRUE) {
        wcout << L"Fișier încărcat: " << szFile << endl;

        ifstream inFile(szFile, ios::binary);
        if (!inFile) {
            cerr << "Eroare la deschiderea fișierului pentru încărcare!" << endl;
            return;
        }

        // Citește numărul de piese și conexiuni
        inFile.read(reinterpret_cast<char*>(&k), sizeof(k));
        inFile.read(reinterpret_cast<char*>(&k2), sizeof(k2));

        // Încarcă piesele și conexiunile direct în `p` și `c`
        inFile.read(reinterpret_cast<char*>(p), k * sizeof(piesa));
        inFile.read(reinterpret_cast<char*>(c), k2 * sizeof(conexiune));

        inFile.close();
    }
}


int main() {

    if (SDL_Init(SDL_INIT_VIDEO) != 0) {
        std::cout << "SDL_Init failed: " << SDL_GetError() << std::endl;
        return 1;
    }

    if (TTF_Init() == -1) {
        std::cout << "TTF_Init failed: " << TTF_GetError() << std::endl;
        SDL_Quit();
        return 1;
    }
    //TTF_Font* font = TTF_OpenFont("C:\\Electron\\Movistar Text Regular.ttf", 20);

    //create window
    SDL_Init(SDL_INIT_VIDEO);
    SDL_Window* window = SDL_CreateWindow("Electron", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 1200, 800, 0);

    //create renderer NOT the same thing as window
    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
    SDL_Event event;
    SDL_SetRenderDrawColor(renderer, 30, 20, 80, 255);
    SDL_RenderClear(renderer);

    int movep = 0, current;
    //int running = 1;
    while (mm) {
        while (SDL_PollEvent(&event)) {
            mainMenu(renderer, event);
            SDL_GetMouseState(&x, &y);
        }
    }

    //set bg color (r g b values)

    citestePiese();
    //drawMenu(renderer);
    //SDL_RenderPresent(renderer);



    //start main loop

    while (running) {
        //here add events= things that happen
        while (SDL_PollEvent(&event)) {
            SDL_GetMouseState(&x, &y);
            //when click
            if (event.type == SDL_MOUSEBUTTONDOWN) {
                //takes mouse position in x y
                SDL_GetMouseState(&x, &y);
                // Verifică dacă click-ul a fost pe butonul Save
                if (x >= saveButton.x && x <= saveButton.x + saveButton.w &&
                    y >= saveButton.y && y <= saveButton.y + saveButton.h) {
                    save(); inbottommenu = 1;
                }

                // Verifică dacă click-ul a fost pe butonul Load
                else if (x >= loadButton.x && x <= loadButton.x + loadButton.w &&
                    y >= loadButton.y && y <= loadButton.y + loadButton.h) {
                    load(); inbottommenu = 1;
                }

                else if (x >= sterge.x && x <= sterge.x + sterge.w &&
                    y >= sterge.y && y <= sterge.y + sterge.h) {
                    deleteAll(); inbottommenu = 1;
                }
                else inbottommenu = 0;

                cout << inPiece(); //de verificare
                current = inPiece();

                if (event.button.button == SDL_BUTTON_RIGHT)
                    c[k2].p2 = 0;//dam cancel la conexiune

                connect(renderer); //wont do anything if we dont connect
                //can connect while moving maybe good maybe bad

                if (moves)moves2 = 1;//otherwise will move the screen infinitely
                else moves2 = 0;

                if (event.button.clicks == 2 && inPiece()) {
                    pm = inPiece();

                }
                if (!inPiece() && !inPieceMenu()) pm = 0;

                if (inPiece()) {
                    rot = rpm = inPiece();
                }
                if (rot && rotateCheck(rot)) {
                    rot2 = rotateCheck(rot);
                }
                

                menu(renderer); //checks if menu was pressed
                if (!clickMenu && !inPieceMenu() && !rotateCheck(rot) && resizeCheck(rpm) == 0&&!inbottommenu) {
                    if (!inPiece() && !moves && !inPunct(x, y, targetPiece, targetPin))createPiece(renderer); //draws if nothing else
                    else movep = 1;
                }
                if (event.button.button == SDL_BUTTON_RIGHT && inPiece())
                    deletePiece(inPiece());
                if (rpm && resizeCheck(rpm)) {
                    resizePiece(p[rpm], 0.1 * resizeCheck(rpm));
                }


            }
            if (x < offsetX + buttonWidth + 30 && event.type == SDL_MOUSEWHEEL) {
                scrollmenuh += event.wheel.y*5;
                if (scrollmenuh > 10)scrollmenuh = 10;
                if (scrollmenuh < -(buttonHeight + spacing) * tipuripiese + maxy)scrollmenuh = -(buttonHeight + spacing) * tipuripiese + maxy;
            }

            if (inPiece() && event.type == SDL_MOUSEMOTION && movep && !moves2) {
                movePiece(renderer, event);
                if (p[inPiece()].a == 1)premovex = x, premovey = y;

            }

            if (movepm) {
                movePieceMenu(renderer, event);
            }

            if (event.type == SDL_MOUSEMOTION && moves2)
                moveScreen(renderer, event);

            if (event.type == SDL_MOUSEBUTTONUP) {
                int aux = inPiece();
                if (p[inPiece()].a == 0)p[aux].x = premovex, p[aux].y = premovey, p[aux].a = 1;
                movep = 0, moves2 = 0, movepm = 0, rot2 = 0;//stops moving
            }


            //when key press
            //resize also maybe move in void somehow??
            if (event.type == SDL_KEYDOWN) {
                if (event.key.keysym.sym == SDLK_RIGHT && current) {
                    resizePiece(p[current], 0.1);
                }
                if (event.key.keysym.sym == SDLK_LEFT && current) {
                    resizePiece(p[current], -0.1);
                }
                if (event.key.keysym.sym == SDLK_RIGHT && moves) {
                    zoomScreen(renderer, 0.1);
                }
                if (event.key.keysym.sym == SDLK_LEFT && moves) {
                    zoomScreen(renderer, -0.1);
                }
                c[k2].p2 = 0;//dam cancel la conexiune
            }

            //when close window = ends main while
            if (event.type == SDL_QUIT) {
                running = 0;
            }
            redrawAll(renderer);
        }
        //resets color after connection turns it white
        SDL_SetRenderDrawColor(renderer, col[t].r, col[t].g, col[t].b, col[t].a);
        //updates screen on every frame = for now NOT necessary but who knows
        //SDL_RenderPresent(renderer);
    }
    return 0;
}
