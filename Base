
#define SDL_MAIN_HANDLED
#define SDL_TTF_H
#define _CRT_SECURE_NO_WARNINGS
#include <SDL.h>
#include <iostream>
#include <cmath>
#include <fstream>
#include <cstring>
#include <SDL_ttf.h>
using namespace std;
//-lSDL2_ttf NU MERGEEEEEEEE
SDL_Texture* texturapiese[3];//self explenatory
//TTF_Font* font = TTF_OpenFont("C:\\Electron\\Movistar Text Regular.ttf", 20);
TTF_Font* font = TTF_OpenFont("C:/Windows/Fonts/arial.ttf", 24);

struct punct {
    float x, y;
};
struct piesa {
    int tip, ori, esteliber[3], b, nrLinii, nrpct, ar = -1, a, lin = -1, ce = -1, r = -1;
    float x, y, h, l, linie[20][4], arc[10][4], cerc[10][4], dr[10][4];
    punct conexiuni[3];
    char nume[200];

}p[100], ogp[100], ptmenu[100];
//pieces and originals we will use as base
struct conexiune {
    int p1, p2, tip, pin1, pin2;
}c[100];

int k = 1, l = 70, h = 70, x, y, t, k2 = 1, nrcol, moves, tipuripiese, moves2, clickMenu, ogk = 3, maxx, maxy, pm = 0, pmx = -1, pmy = -1, pml, pmh, movepm = 0, premovex, premovey;
float scaleFactor = 50.0f;
//TTF_Font* font = TTF_OpenFont("C:\Electron\Movistar Text Regular.ttf", 20);

//colors we will use, to be updated later with prettier ones
SDL_Color col[10] = {
    {255,0,0,255},
    {0,255,0,255},
    {0,0,255,255}
};
void desenareLinie(SDL_Renderer* renderer, float x1, float y1, float x2, float y2, float scaleFactor) {
    SDL_RenderDrawLine(renderer, x1, y1, x2, y2);
}

void desenareCerc(SDL_Renderer* renderer, float cx, float cy, float rx, float ry, float scaleFactor) {
    for (int angle = 0; angle < 360; angle++) {
        float radian = angle * (3.14159 / 180);
        float x = cx + rx * cos(radian);
        float y = cy + ry * sin(radian);
        SDL_RenderDrawPoint(renderer, (int)(x), (int)(y));
    }
}

// Functie care deseneaza un arc cu partea goala spre dreapta
void desenareArc(SDL_Renderer* renderer, float x1, float y1, float x2, float y2) {
    // Raza cercului este jumătate din distanța dintre punctele de start și final
    float radius = (x2 - x1) / 2.0f;

    // Centrul cercului
    float cx = x1 + radius;
    float cy = y1; // Centrul pe linia orizontală Y

    // Unghiurile de început și de final (acoperim 180°)
    float startAngle = M_PI / 2.0f;     // 90 de grade (sus)
    float endAngle = 3 * M_PI / 2.0f;   // 270 de grade (jos)

    // Segmentare pentru desen (precum un arc împărțit în multe linii)
    const int segments = 100; // Mai multe segmente = arc mai lin
    float angleStep = (endAngle - startAngle) / segments;

    // Desenăm arcul segment cu segment
    for (int i = 0; i < segments; i++) {
        float angle1 = startAngle + i * angleStep;
        float angle2 = startAngle + (i + 1) * angleStep;

        // Puncte pe arc
        float xStart = cx + radius * cos(angle1);
        float yStart = cy - radius * sin(angle1);  // Y este inversat pentru a fi sus pe ecran
        float xEnd = cx + radius * cos(angle2);
        float yEnd = cy - radius * sin(angle2);    // Y inversat pentru sus pe ecran

        // Desenăm linia între punctele adiacente
        SDL_RenderDrawLine(renderer, (int)xStart, (int)yStart, (int)xEnd, (int)yEnd);
    }
}



void menu(SDL_Renderer* renderer) {
    clickMenu = 0;
    SDL_GetRendererOutputSize(renderer, &maxx, &maxy);
    //3 buttons for now each changing the piece we'll use
    if (x <= 100) {
        if (y <= 70) {
            t = 1;
            //changes color to the first one
            //nvm color will be based on type t
        }
        else if (y <= 140) {
            t = 2;
        }
        else if (y <= 210) {
            t = 3;

        }
        else if (y <= 280)
            t = 4;
        else if (y <= 350)
            t = 5;
        else if (y <= 420)
            t = 6;
        else if (y <= 490)
            t = 7;
        l = ogp[t].l, h = ogp[t].h; //select base piece

        SDL_SetRenderDrawColor(renderer, col[t].r, col[t].g, col[t].b, col[t].a);
        clickMenu = 1;
        moves = 0;
    }
    if (x >= maxx - 100 && y <= 100)
        moves = 1, clickMenu = 1, cout << moves;
}


void drawMenu(SDL_Renderer* renderer) {
    int maxx, maxy;
    SDL_GetRendererOutputSize(renderer, &maxx, &maxy);

    int buttonWidth = 70;  // Dimensiunea fiecărui buton
    int buttonHeight = 70;
    int spacing = 10;       // Spațiere între butoane
    int offsetX = 0;        // Poziția X inițială
    int offsetY = 0;        // Poziția Y inițială

    for (int i = 1; i <= tipuripiese; i++) {
        // Definim zona pentru buton
        SDL_Rect buttonRect = { offsetX, offsetY, buttonWidth, buttonHeight };

        // Desenează fundalul butonului
        SDL_SetRenderDrawColor(renderer, 200, 200, 200, 255); // Gri deschis
        SDL_RenderFillRect(renderer, &buttonRect);

        // Desenează conturul butonului
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255); // Negru
        SDL_RenderDrawRect(renderer, &buttonRect);

        // Scalează coordonatele pieselor
        float usableWidth = buttonWidth * 0.8f;  // 80% din dimensiunea butonului
        float usableHeight = buttonHeight * 0.8f;
        float scaleX = usableWidth / 7.0f;     // Normalizăm la 200x200
        float scaleY = usableHeight / 7.0f;
        float scale = fmin(scaleX, scaleY);      // Păstrăm proporțiile
        float centerX = buttonRect.x + buttonWidth / 2.0f;
        float centerY = buttonRect.y + buttonHeight / 2.0f;

        // Desenează linii
        for (int j = 0; j <= ptmenu[i].lin; j++) {
            float x1 = centerX + ptmenu[i].linie[j][0] * scale;
            float y1 = centerY + ptmenu[i].linie[j][1] * scale;
            float x2 = centerX + ptmenu[i].linie[j][2] * scale;
            float y2 = centerY + ptmenu[i].linie[j][3] * scale;
            desenareLinie(renderer, x1, y1, x2, y2, 1.0f);
            //if (i == 1) cout <<endl <<j << " ";
        }

        // Desenează cercuri
        for (int j = 0; j <= ptmenu[i].ce; j++) {
            float cx = centerX + ptmenu[i].cerc[j][0] * scale;
            float cy = centerY + ptmenu[i].cerc[j][1] * scale;
            float radius = ptmenu[i].cerc[j][2] * scale;
            desenareCerc(renderer, cx, cy, radius, radius, 1.0f);
        }

        // Desenează dreptunghiuri
        for (int j = 0; j <= ptmenu[i].r; j++) {
            float x = centerX + ptmenu[i].dr[j][0] * scale;
            float y = centerY + ptmenu[i].dr[j][1] * scale;
            float w = ptmenu[i].dr[j][2] * scale;
            float h = ptmenu[i].dr[j][3] * scale;
            SDL_Rect rect = { (int)x, (int)y, (int)w, (int)h };
            SDL_RenderDrawRect(renderer, &rect);
        }

        // Desenează arcuri
        for (int j = 0; j <= ptmenu[i].ar; j++) {
            float cx = centerX + ptmenu[i].arc[j][0] * scale;
            float cy = centerY + ptmenu[i].arc[j][1] * scale;
            float r1 = ptmenu[i].arc[j][2] * scale;
            float r2 = ptmenu[i].arc[j][3] * scale;
            desenareArc(renderer, cx, cy, r1, r2);
        }

        // Avansează la următorul buton
        offsetY += buttonHeight + spacing;
        if (offsetY + buttonHeight > maxy) {
            offsetY = 0;
            offsetX += buttonWidth + spacing;
        }
    }
}

void text(SDL_Renderer* renderer, char t[100], int x, int y) {
    TTF_Font* font = TTF_OpenFont("C:\\Electron\\Movistar Text Regular.ttf", 20);
    SDL_Color color = { 255, 255, 255 };  // White

    

    const char* text = t;
    SDL_Surface* surface = TTF_RenderText_Solid(font, text, color);

    SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, surface);
    SDL_FreeSurface(surface);  // Free surface after creating texture


    SDL_Rect destRect = { x, y, strlen(t)*10, 40};
    SDL_RenderCopy(renderer, texture, NULL, &destRect);
}

void drawPieceMenu(SDL_Renderer* renderer, int& pm) {
    if (pm) {
        if (pmx == -1 && pmy == -1)
            pmx = maxx - 250, pmy = maxy - 400, pml = 250, pmh = 400;

        SDL_SetRenderDrawColor(renderer, 100, 57, 94, 255);
        SDL_Rect menup = { pmx, pmy, pml, pmh };
        SDL_RenderFillRect(renderer, &menup);

        SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
        menup = { int(pmx + pml * 0.85), pmy, int(pml * 0.15), int(pml * 0.15) };
        //cout<<pmx<< " "<<pmy<< " "<<pmx+pml*0.9<< " "<<pmy+pmh*0.9<<endl;
        SDL_RenderFillRect(renderer, &menup);

        SDL_SetRenderDrawColor(renderer, 100, 100, 100, 255);
        menup = { pmx, pmy, int(pml * 0.85), int(pml * 0.15) };
        SDL_RenderFillRect(renderer, &menup);


        //va trb sa adaug text..alta librarie..
       
        char t[100] = "Piesa ";
        t[strlen(t)] = char(pm + '0');
        text(renderer, t, pmx, pmy);

        strcpy(t, "Tip: ");
        strcat(t, ptmenu[p[pm].tip].nume);
        text(renderer, t, pmx, pmy+50);

        for (int i = 1;i <= ptmenu[p[pm].tip].nrpct; i++) {
            sprintf(t, "Conexiunea %d: %s", i, (p[pm].esteliber == 0) ? "Liber" : "Ocupat");
            text(renderer, t, pmx, pmy + 50 * (i + 1));
        }


    }
}

int inPieceMenu() {
    if (x >= pmx && x <= pmx + pml && y >= pmy && y <= pmy + pmh) {
        if (x >= int(pmx + pml * 0.85) && y <= int(pmy + pml * 0.15))
            pm = 0;
        else if (x<int(pmx + pml * 0.85) && y <= int(pmy + pmh * 0.15))
            movepm = 1;
        else movepm = 0;
        cout << movepm;
        return 1;
    }
    return 0;
}

void drawConnectionPoints(SDL_Renderer* renderer, piesa& piesa) {
    // Setează culoarea mov pentru dreptunghiuri
    SDL_SetRenderDrawColor(renderer, 255, 0, 255, 255); // Mov
    int j = piesa.tip;
    // Desenăm dreptunghiuri la punctele de conexiune
    for (int i = 0; i < ptmenu[j].nrpct; ++i) {

        float pointX = piesa.x + ptmenu[j].conexiuni[i].x * 15;
        float pointY = piesa.y + ptmenu[j].conexiuni[i].y * 15;


        SDL_Rect rect = { pointX - piesa.l / 8.75, pointY - piesa.h / 8.75, piesa.l / 8.75, piesa.h / 8.75 }; // Ajustăm pentru a plasa punctul în mijloc
        SDL_RenderFillRect(renderer, &rect);


    }
}

void drawPiece(SDL_Renderer* renderer, int i) {

    //piese inserate
    SDL_Rect rect = { p[i].x - p[i].l / 2,p[i].y - p[i].h / 2,p[i].l,p[i].h };
    if (p[i].a == 0)
    {
        SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
        SDL_RenderFillRect(renderer, &rect);
    }
    else
    {
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255); // Negru
        int y = p[i].tip, scale = 15;

        // Desenează linii
        for (int j = 0; j <= ptmenu[y].lin; j++) {

            float x1 = p[i].x + ptmenu[y].linie[j][0] * scale;
            float y1 = p[i].y + ptmenu[y].linie[j][1] * scale;
            float x2 = p[i].x + ptmenu[y].linie[j][2] * scale;
            float y2 = p[i].y + ptmenu[y].linie[j][3] * scale;
            desenareLinie(renderer, x1, y1, x2, y2, 1.0f);
            //if (i == 1) cout <<endl <<j << " ";
        }

        // Desenează cercuri
        for (int j = 0; j <= ptmenu[y].ce; j++) {
            float cx = p[i].x + ptmenu[y].cerc[j][0] * scale;
            float cy = p[i].y + ptmenu[y].cerc[j][1] * scale;
            float radius = ptmenu[y].cerc[j][2] * scale;
            desenareCerc(renderer, cx, cy, radius, radius, 1.0f);
        }

        // Desenează dreptunghiuri
        for (int j = 0; j <= ptmenu[y].r; j++) {
            float x = p[i].x + ptmenu[y].dr[j][0] * scale;
            float y1 = p[i].y + ptmenu[y].dr[j][1] * scale;
            float w = ptmenu[y].dr[j][2] * scale;
            float h = ptmenu[y].dr[j][3] * scale;
            SDL_Rect rect = { (int)x, (int)y1, (int)w, (int)h };
            SDL_RenderDrawRect(renderer, &rect);
        }

        // Desenează arcuri
        for (int j = 0; j <= ptmenu[y].ar; j++) {
            float cx = p[i].x + ptmenu[i].arc[j][0] * scale;
            float cy = p[i].y + ptmenu[i].arc[j][1] * scale;
            float r1 = ptmenu[y].arc[j][2] * scale;
            float r2 = ptmenu[y].arc[j][3] * scale;
            desenareArc(renderer, cx, cy, r1, r2);
        }

        drawConnectionPoints(renderer, p[i]);
    }




}
void citestePiese()
{
    int i, j;
    char c = 0;
    ifstream f("C:\\Electron.txt");
    if (!f.is_open()) {
        cout << "Nu s-a putut deschide fișierul!" << endl;

    }
    f >> tipuripiese;
    f.ignore(numeric_limits<streamsize>::max(), '\n');
    for (i = 1;i <= tipuripiese;i++)
    {

        f.get(ptmenu[i].nume, 200);
        f.ignore(numeric_limits<streamsize>::max(), '\n');
        f >> ptmenu[i].nrpct;
        f.ignore(numeric_limits<streamsize>::max(), '\n');
        for (j = 0;j < ptmenu[i].nrpct;j++)
        {
            f >> ptmenu[i].conexiuni[j].x >> ptmenu[i].conexiuni[j].y;
            f.ignore(numeric_limits<streamsize>::max(), '\n');

        }
        f >> ptmenu[i].nrLinii;
        f.ignore(numeric_limits<streamsize>::max(), '\n');
        for (j = 0;j < ptmenu[i].nrLinii;j++) {
            int k;
            f >> c;
            if (c == 'A')
            {
                ++ptmenu[i].ar;
                for (k = 0;k < 4;k++)
                    f >> ptmenu[i].arc[ptmenu[i].ar][k];
            }
            else if (c == 'L')
            {
                ++ptmenu[i].lin;  for (k = 0;k < 4;k++)
                    f >> ptmenu[i].linie[ptmenu[i].lin][k];
            }
            else if (c == 'O')
            {
                ++ptmenu[i].ce;
                for (k = 0;k < 4;k++)
                    f >> ptmenu[i].cerc[ptmenu[i].ce][k];
            }
            else if (c == 'R')
            {
                ++ptmenu[i].r;
                for (k = 0;k < 4;k++)
                    f >> ptmenu[i].dr[ptmenu[i].r][k];
            }
            f.ignore(numeric_limits<streamsize>::max(), '\n');

        }



    }

    f.close();



}
void createPiece(SDL_Renderer* renderer) {
    int i;
    p[k].x = x, p[k].y = y;
    p[k].l = 70, p[k].h = 70, p[k].tip = t;

    p[k++].ori = 0;
    for (i = 0;i < 3;i++)
        p[k - 1].esteliber[i] = 1;
    p[k - 1].a = p[k - 1].b = 1;
    drawPiece(renderer, k - 1);


}

void deleteConnection(int i, int x, int pin) {
    cout << "jezz" << i;
    p[x].esteliber[pin]--;

    for (int j2 = i;j2 < k2;j2++)
        c[j2] = c[j2 + 1];

    k2--;
}

void deletePiece(int i) {
    int j;
    for (j = 1;j <= k2;j++)
    {
        if (c[j].p1 == i) {
            deleteConnection(j, c[j].p2, c[j].pin2);

            j--;
        }
        if (c[j].p2 == i)
        {
            deleteConnection(j, c[j].p1, c[j].pin1);
            j--;
        }


    }
    for (j = 1; j <= k2; ++j) {
        if (c[j].p1 > i) c[j].p1--;
        if (c[j].p2 > i) c[j].p2--;
    }
    for (j = i;j < k;j++)
        p[j] = p[j + 1];
    k--;



}

int inPiece() {

    //return which piece was clicked, 0 if no piece
    for (int i = 0;i < k;i++) {

        if (x > p[i].x - p[i].l / 2 && x < p[i].x + p[i].l / 2)
        {

            if (y > p[i].y - p[i].h / 2 && y < p[i].y + p[i].h / 2)
                return i;
        }
    }
    return 0;
}

void movePiece(SDL_Renderer* renderer, SDL_Event event) {
    c[k2].p2 = 0;
    SDL_GetMouseState(&x, &y);
    int i = inPiece(), ok = 1, j;
    p[inPiece()].x += event.motion.xrel; // moves position
    p[inPiece()].y += event.motion.yrel;
    for (j = 1;j <= k && ok;j++)
        if (abs(p[j].x - p[i].x) < (p[j].l + p[i].l) / 2 && abs(p[j].y - p[i].y) < (p[j].l + p[i].l) / 2 && i != j)
        {
            p[i].a = 0;
            p[i].b = j;
            ok = 0;
        }
    if (ok)
    {
        p[i].a = 1;
        p[p[i].b].a = 1;
    }
}

void movePieceMenu(SDL_Renderer* renderer, SDL_Event event) {
    c[k2].p2 = 0;
    SDL_GetMouseState(&x, &y);

    pmx += event.motion.xrel; // moves position
    pmy += event.motion.yrel;
    //cout<<pmx<< " "<<pmy<<endl;
}

int inPunct(float mouseX, float mouseY, int& piesaselectata, int& pinselectat) {
    int i;
    for (i = 0;i < k;i++)
        for (int j = 0; j < ptmenu[p[i].tip].nrpct; j++) {

            float pointX = p[i].x + p[i].conexiuni[j].x * 15;
            float pointY = p[i].y + p[i].conexiuni[j].y * 15;
            float size = p[i].l / 5; // marimea punctului

            //  mouse ul este peste punct
            if (mouseX >= pointX - size && mouseX <= pointX + size &&
                mouseY >= pointY - size && mouseY <= pointY + size) {
                for (int k = 0;k < ptmenu[p[i].tip].nrpct;k++)
                    p[i].conexiuni[k] = ptmenu[p[i].tip].conexiuni[k];
                piesaselectata = i;
                pinselectat = j;
                return 1;
            }

        }

    return 0;
}
int sourcePiece = -1, targetPiece = -1, sourcePin = -1, targetPin = -1;

void dirVector(int& a, int& b) {
    //saves most important direction
    //if its more to the right than up then it will be right etc
    if (abs(a) > abs(b)) {
        a = (a > 0) - (a < 0);
        b = 0;
    }
    else {
        b = (b > 0) - (b < 0);
        a = 0;
    }
}

void drawConnect(SDL_Renderer* renderer, int i) {

    //black line between 2 pieces, to be changed later
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 0);
    //SDL_RenderDrawLine(renderer, p[c[i].p1].conexiuni[c[i].pin1].x + p[c[i].p1].x - p[c[i].p1].l / 2, p[c[i].p1].conexiuni[c[i].pin1].y + p[c[i].p1].y - p[c[i].p1].h / 2,
        //p[c[i].p2].conexiuni[c[i].pin2].x +p[c[i].p2].x -p[c[i].p2].l / 2, p[c[i].p2].conexiuni[c[i].pin2].y+p[c[i].p2].y - p[c[i].p2].h / 2);
    int x1 = p[c[i].p1].conexiuni[c[i].pin1].x*15 + p[c[i].p1].x;// -p[c[i].p1].l / 2 - p[c[i].p1].l / 17;
    int y1 = p[c[i].p1].conexiuni[c[i].pin1].y*15 + p[c[i].p1].y;// -p[c[i].p1].h / 2 - p[c[i].p1].h / 17;
    int x2 = p[c[i].p2].conexiuni[c[i].pin2].x*15 + p[c[i].p2].x;// -p[c[i].p2].l / 2 - p[c[i].p1].l / 17;
    int y2 = p[c[i].p2].conexiuni[c[i].pin2].y*15 + p[c[i].p2].y;// -p[c[i].p2].h / 2 - p[c[i].p1].h / 17;
    //cout << x1 << ' ' << y1 << " " << x2 << " " << y2 << endl;
    int leftright1, updown1, leftright2, updown2, lc;

    lc = abs(x2 - x1) / 3 + 10;

    //1 if right/up -1 if left/down
    leftright1 = x1 - p[c[i].p1].x;
    updown1 = y1 - p[c[i].p1].y;
    dirVector(leftright1, updown1);

    //small line to continue the direction
    SDL_RenderDrawLine(renderer, x1, y1, x1 + leftright1 * lc, y1 + updown1 * lc);
    x1 = x1 + leftright1 * lc, y1 = y1 + updown1 * lc; //updates where we are


    //same for second one
    leftright2 = x2 - p[c[i].p2].x;
    updown2 = y2 - p[c[i].p2].y;
    dirVector(leftright2, updown2);

    SDL_RenderDrawLine(renderer, x2, y2, x2 + leftright2 * lc, y2 + updown2 * lc);
    x2 = x2 + leftright2 * lc, y2 = y2 + updown2 * lc;
    //cout<<x1<< " "<<y1<< " "<<x2<< " "<<y2<<leftright1<< " "<<updown2<<endl;
    //390 214 267 3451 -1
    //787 416 609 439 1 0 -1 1
    if (leftright2 && leftright2 == -updown1 || (leftright1 == -leftright2 && leftright1 == -1) || x1 > x2)
        swap(x1, x2), swap(y1, y2), swap(leftright1, leftright2), swap(updown1, updown2);
    if (leftright1 == -1 && leftright1 == -updown2 && x1 < x2) {
        SDL_RenderDrawLine(renderer, x1, y1, x1, max(y2, y1 + lc));
        y1 = max(y2, y1 + lc);
    }
    if (leftright1 == 1 && leftright1 == -updown2 && x1 > x2 && y2 >= y1) {
        //SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
        SDL_RenderDrawLine(renderer, x1, y1, x1, max(y2, y1 + lc));
        y1 = max(y2, y1 + lc);
    }
    if (updown1 == 1 && updown1 == leftright2 && x1 > x2) {
        SDL_RenderDrawLine(renderer, x2, y2, x2, max(y1, y2 + lc));
        y2 = max(y1, y2 + lc);
        //cout<<x1<< " "<<y1<< " "<<x2<< " "<<y2<<leftright1<< " "<<updown2<<endl;
    }
    //cout<<x1<< " "<<y1<< " "<<x2<< " "<<y2<<leftright1<< " "<<updown2<<endl;
    if (updown2 == -1 && updown2 == leftright1 && y2 < y1) {
        SDL_RenderDrawLine(renderer, x1, y1, x1, y1 + lc);
        y1 = y1 + lc;
        //cout<<x1<< " "<<y1<< " "<<x2<< " "<<y2<<" "<<leftright1<< " "<<updown2<<endl;
    }

    //SDL_SetRenderDrawColor(renderer, 0, 255, 0, 255);
    if (updown1 != 0) {
        int aux;
        if (updown1 == 1) {
            aux = max(y1, y2);
        }
        else aux = min(y1, y2);
        SDL_RenderDrawLine(renderer, x1, y1, x1, aux);
        y1 = aux; //so that we get a rounder form if both are vertical
        SDL_RenderDrawLine(renderer, x1, y1, x1 + (x2 - x1) / 4, y1);
        x1 = x1 + (x2 - x1) / 4;
        leftright1 = -leftright2; //so that we get a less harsh connection if one is vertical the other horizontal
    }
    //same for second
    if (updown2 != 0) {
        int aux;
        if (updown2 == 1) {
            aux = max(y1, y2);
        }
        else aux = min(y1, y2);
        SDL_RenderDrawLine(renderer, x2, y2, x2, aux);
        y2 = aux;
        SDL_RenderDrawLine(renderer, x2, y2, x2 + (x1 - x2) / 4, y2);
        x2 = x2 + (x1 - x2) / 4;
        leftright2 = -leftright1;//working primarily horizontally
    }
    //SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    //cadranu 3 reparat
    if ((x1 > x2 && leftright2 == -1) || (x1 < x2 && leftright2 == 1) || updown1 == leftright2)
        swap(x1, x2), swap(y1, y2), swap(leftright1, leftright2), swap(updown1, updown2);
    //so we'll need less cases as x1 is the smaller one

    //SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
    //787 416 609 439 1 0 -1 1
    if (leftright1 * leftright2 < 0 && leftright1 == -1 && !updown2) {
        SDL_RenderDrawLine(renderer, x2, y2, x2, min(y2 - lc / 2, (y1 + y2 / 2)));
        y2 = min(y2 - lc / 2, (y1 + y2 / 2));
    }
    //SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);

    //cout<<x1<< " "<<y1<< " "<<x2<< " "<<y2<<" "<<leftright1<< " "<<updown1<< " "<<leftright2<< " "<<updown2<<endl;

    //750 274 566 338 1 0 -1 1
    //SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
    if (leftright1 * leftright2<0 && leftright2 == -1 && !updown1 && x1>x2) {
        //swap(x1, x2), swap(y1, y2), swap(leftright1, leftright2), swap(updown1, updown2);
        SDL_RenderDrawLine(renderer, x1, y1, x1, max((y1 + y2) / 2, y1 + lc / 2));
        y1 = max((y1 + y2) / 2, y1 + lc / 2);
        swap(x1, x2), swap(y1, y2), swap(leftright1, leftright2), swap(updown1, updown2);
    }
    //SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);

    //for the cases in which theyre going in opposite directions
    if (updown1 * updown2 < 0) {
        SDL_RenderDrawLine(renderer, x2, y2, x2 + (x1 - x2) / 3, y2);
        x2 = x2 + (x1 - x2) / 3;
    }
    //SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    //idk if the if else is necessary tbh
    if (x1 > x2 && leftright1 == updown2 == -1)
        swap(x1, x2), swap(y1, y2), swap(leftright1, leftright2), swap(updown1, updown2);
    if (updown1 && updown2) {
        SDL_RenderDrawLine(renderer, x1, y1, x2, y1);
        SDL_RenderDrawLine(renderer, x2, y1, x2, y2);
    }
    else {
        SDL_RenderDrawLine(renderer, x1, y1, x1, y2);
        SDL_RenderDrawLine(renderer, x1, y2, x2, y2);
    }
}
void connect(SDL_Renderer* renderer) {

    // Găsește piesa și pinul sursă
    if (targetPiece != -1 && targetPiece != sourcePiece || sourcePiece == -1) {
        sourcePiece = -1, targetPiece = -1, sourcePin = -1, targetPin = -1;

        if (!inPunct(x, y, sourcePiece, sourcePin)) {
            cout << "Nu s-a selectat un punct valid pentru conexiune." << endl;
            return;
        }
    }


    // Găsește piesa și pinul destinație
    if (!inPunct(x, y, targetPiece, targetPin) || sourcePiece == targetPiece) {
        cout << "Nu se poate realiza conexiunea." << sourcePiece << " " << targetPiece << endl;
        return;
    }



    // Creează conexiunea
    c[k2] = { sourcePiece, targetPiece, 0, sourcePin, targetPin };
    p[sourcePiece].esteliber[sourcePin]++;
    p[targetPiece].esteliber[targetPin]++;

    drawConnect(renderer, k2);

    k2++;

    cout << "Conexiune realizată între piesa " << sourcePiece << " și " << targetPiece << "." << endl;


}

void moveScreen(SDL_Renderer* render, SDL_Event event) {
    SDL_GetMouseState(&x, &y);
    int i;
    for (i = 1;i < k;i++) {
        p[i].x += event.motion.xrel; // moves position
        p[i].y += event.motion.yrel;
    }
}

void zoomScreen(SDL_Renderer* renderer, float zoom) {
    SDL_GetMouseState(&x, &y);
    int i;
    for (i = 1;i < k;i++) {
        p[i].x += (p[i].x - x) * zoom; // moves position
        p[i].y += (p[i].y - y) * zoom;
        p[i].l += p[i].l * zoom;
        p[i].h += p[i].h * zoom;
    }
    for (i = 0;i < ogk;i++) {
        ogp[i].l += ogp[i].l * zoom;
        ogp[i].h += ogp[i].h * zoom;

    }
}

void drawLine(SDL_Renderer* renderer) {
    //no use for testing only
    SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
    SDL_RenderDrawLine(renderer, 100, 100, 700, 500);
}


void redrawAll(SDL_Renderer* renderer) {
    int i;
    SDL_SetRenderDrawColor(renderer, 255, 182, 193, 255);
    SDL_RenderClear(renderer);
    //drawMenu(renderer);
    for (i = 1;i < k;i++) {
        drawPiece(renderer, i);
    }
    for (i = 1;i < k2;i++) {
        drawConnect(renderer, i);
    }
    drawMenu(renderer);
    drawPieceMenu(renderer, pm);
    SDL_RenderPresent(renderer);
}


int main() {

    if (SDL_Init(SDL_INIT_VIDEO) != 0) {
        std::cout << "SDL_Init failed: " << SDL_GetError() << std::endl;
        return 1;
    }

    if (TTF_Init() == -1) {
        std::cout << "TTF_Init failed: " << TTF_GetError() << std::endl;
        SDL_Quit();
        return 1;
    }
    //TTF_Font* font = TTF_OpenFont("C:\\Electron\\Movistar Text Regular.ttf", 20);

    //create window
    SDL_Init(SDL_INIT_VIDEO);
    SDL_Window* window = SDL_CreateWindow("Fereastra SDL2", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 1200, 800, 0);

    //create renderer NOT the same thing as window
    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
    SDL_Event event;

    //set bg color (r g b values)
    SDL_SetRenderDrawColor(renderer, 30, 20, 80, 255);
    SDL_RenderClear(renderer);
    citestePiese();
    drawMenu(renderer);
    SDL_RenderPresent(renderer);


    //start main loop
    int movep = 0, current;
    int running = 1;
    while (running) {
        //here add events= things that happen
        while (SDL_PollEvent(&event)) {
            SDL_GetMouseState(&x, &y);
            //when click
            if (event.type == SDL_MOUSEBUTTONDOWN) {
                //takes mouse position in x y
                SDL_GetMouseState(&x, &y);

                cout << inPiece(); //de verificare
                current = inPiece();

                if (event.button.button == SDL_BUTTON_RIGHT)
                    c[k2].p2 = 0;//dam cancel la conexiune

                connect(renderer); //wont do anything if we dont connect
                //can connect while moving maybe good maybe bad

                if (moves)moves2 = 1;//otherwise will move the screen infinitely
                else moves2 = 0;

                if (event.button.clicks == 2 && inPiece()) {
                    pm = inPiece();

                }
                if (!inPiece() && !inPieceMenu()) pm = 0;

                menu(renderer); //checks if menu was pressed
                if (!clickMenu && !inPieceMenu()) {
                    if (!inPiece() && !moves && !inPunct(x, y, targetPiece, targetPin))createPiece(renderer); //draws if nothing else
                    else movep = 1;//placeholder trb mutat in void separat
                }
                if (event.button.button == SDL_BUTTON_RIGHT && inPiece())
                    deletePiece(inPiece());

            }
            if (inPiece() && event.type == SDL_MOUSEMOTION && movep && !moves2) {
                movePiece(renderer, event);
                if (p[inPiece()].a == 1)premovex = x, premovey = y;

            }

            if (movepm) {
                movePieceMenu(renderer, event);
            }

            if (event.type == SDL_MOUSEMOTION && moves2)
                moveScreen(renderer, event);

            if (event.type == SDL_MOUSEBUTTONUP) {
                int aux = inPiece();
                if (p[inPiece()].a == 0)p[aux].x = premovex, p[aux].y = premovey, p[aux].a = 1;
                movep = 0, moves2 = 0, movepm = 0;//stops moving
            }


            //when key press
            //resize also maybe move in void somehow??
            if (event.type == SDL_KEYDOWN) {
                if (event.key.keysym.sym == SDLK_RIGHT && current) {
                    p[current].l += 0.1 * p[current].l;
                    p[current].h += 0.1 * p[current].h;
                }
                if (event.key.keysym.sym == SDLK_LEFT && current) {
                    p[current].l -= 0.1 * p[current].l;
                    p[current].h -= 0.1 * p[current].h;
                }
                if (event.key.keysym.sym == SDLK_RIGHT && moves) {
                    zoomScreen(renderer, 0.1);
                }
                if (event.key.keysym.sym == SDLK_LEFT && moves) {
                    zoomScreen(renderer, -0.1);
                }
                c[k2].p2 = 0;//dam cancel la conexiune
            }

            //when close window = ends main while
            if (event.type == SDL_QUIT) {
                running = 0;
            }
            redrawAll(renderer);
        }
        //resets color after connection turns it white
        SDL_SetRenderDrawColor(renderer, col[t].r, col[t].g, col[t].b, col[t].a);
        //updates screen on every frame = for now NOT necessary but who knows
        //SDL_RenderPresent(renderer);
    }
    return 0;
}
