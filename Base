#define SDL_MAIN_HANDLED
#define SDL_TTF_H
#define _CRT_SECURE_NO_WARNINGS
#include <SDL.h>
#include <iostream>
#include <cmath>
#include <fstream>
#include <cstring>
#include <SDL_ttf.h>
#define NOMINMAX
#include <Windows.h>
#include <commdlg.h>
using namespace std;
//-lSDL2_ttf NU MERGEEEEEEEE
SDL_Texture* texturapiese[3];//self explenatory
//TTF_Font* font = TTF_OpenFont("C:\\Electron\\Movistar Text Regular.ttf", 20);
TTF_Font* font = TTF_OpenFont("C:/Windows/Fonts/arial.ttf", 24);
SDL_Rect saveButton, loadButton, sterge, reface, createRect;
struct punct {
    float x, y;
};
struct piesa {
    int tip, ori, ori2, esteliber[10], b, nrLinii, nrpct, ar = -1, a, lin = -1, ce = -1, r = -1;
    float x, y, h, l, linie[30][4], arc[10][4], cerc[10][4], dr[10][4], value[3];
    punct conexiuni[10];
    char nume[200];

}p[100], ogp[100], ptmenu[100], newPiece;
//pieces and originals we will use as base
struct conexiune {
    int p1, p2, tip, pin1, pin2;
}c[100];

int undod[1000], u = 0, meow, ham, k = 1, l = 70, h = 70, x, y, t = 1, k2 = 1, nrcol, moves, tipuripiese, moves2, clickMenu, ogk = 3, maxx, maxy, pm = 0, pmx = -1, pmy = -1, pml, pmh, movepm = 0, premovex, premovey;
int rot, rot2, mm = 1, running = 1, rpm, theme = 1, inbottommenu, selectbutton, ch, cinning, whichValue, cinPiece, cm, newk, drawType=1, snap, newCheck=0, undov[30], undonr, undocount;
int arc1, arc2;
float scaleFactor = 50.0f;
char textcin[255];
int buttonWidth = 70;  // Dimensiunea fiecărui buton
int buttonHeight = 70;
int spacing = 10;       // Spațiere între butoane
int offsetX = 10;        // Poziția X inițială
int offsetY = 30, scrollmenuh = 10;        // Poziția Y inițială

//TTF_Font* font = TTF_OpenFont("C:\Electron\Movistar Text Regular.ttf", 20);

//colors we will use, to be updated later with prettier ones
SDL_Color col[40] = {
    {15, 29, 46,255},
    {72, 192, 240,255},
    {38, 129, 199,255},
    {183, 207, 237, 255}, //col basic

    {15, 29, 46,255},
    {72, 192, 240,255},
    {38, 129, 199,255},
    {183, 207, 237, 255},// theme 1

    {21, 21, 23,255},
    {64, 61, 64,255},
    {58, 54, 58,255},
    {227, 222, 227, 255},//theme 2

    {59, 27, 49,255},
    {240, 72, 159,255},
    {191, 13, 93,255},
    {245, 201, 231, 255},//theme 3

    {43, 27, 26,255},
    {217, 97, 41,255},
    {133, 38, 25,255},
    {235, 191, 178, 255}, //theme 4

    {24, 54, 28,255},
    {201, 16, 32,255},
    {25, 125, 14,255},
    {247, 225, 225, 255}, //theme 5
};
void desenareLinie(SDL_Renderer* renderer, float x1, float y1, float x2, float y2, float scaleFactor) {
    SDL_RenderDrawLine(renderer, x1, y1, x2, y2);
}

void desenareCerc(SDL_Renderer* renderer, float cx, float cy, float rx, float ry, float scaleFactor) {
    for (int angle = 0; angle < 360; angle++) {
        float radian = angle * (3.14159 / 180);
        float x = cx + rx * cos(radian);
        float y = cy + ry * sin(radian);
        SDL_RenderDrawPoint(renderer, (int)(x), (int)(y));
    }
}

// Functie care deseneaza un arc cu partea goala spre dreapta
void desenareArc(SDL_Renderer* renderer, float x1, float y1, float x2, float y2) {
    // Raza cercului este jumătate din distanța dintre punctele de start și final
    float radius = (x2 - x1) / 2.0f;

    // Centrul cercului
    float cx = x1 + radius;
    float cy = y1; // Centrul pe linia orizontală Y

    // Unghiurile de început și de final (acoperim 180°)
    float startAngle = M_PI / 2.0f;     // 90 de grade (sus)
    float endAngle = 3 * M_PI / 2.0f;   // 270 de grade (jos)

    // Segmentare pentru desen (precum un arc împărțit în multe linii)
    const int segments = 100; // Mai multe segmente = arc mai lin
    float angleStep = (endAngle - startAngle) / segments;

    // Desenăm arcul segment cu segment
    for (int i = 0; i < segments; i++) {
        float angle1 = startAngle + i * angleStep;
        float angle2 = startAngle + (i + 1) * angleStep;

        // Puncte pe arc
        float xStart = cx + radius * cos(angle1);
        float yStart = cy - radius * sin(angle1);  // Y este inversat pentru a fi sus pe ecran
        float xEnd = cx + radius * cos(angle2);
        float yEnd = cy - radius * sin(angle2);    // Y inversat pentru sus pe ecran

        // Desenăm linia între punctele adiacente
        SDL_RenderDrawLine(renderer, (int)xStart, (int)yStart, (int)xEnd, (int)yEnd);
    }
}


/*void esteplin() {
    if (u == 998)
        for (int i = 1;i <= 98;i++)
            undo[i] = undo[i + 900], cout << "cee";
    u = 98;
}*/
void menu(SDL_Renderer* renderer) {
    clickMenu = 0; //cout << x << " " << y << endl;
    SDL_GetRendererOutputSize(renderer, &maxx, &maxy);
    //3 buttons for now each changing the piece we'll use
    if (x <= offsetX + buttonWidth + 10) {
        if (y <= tipuripiese * 80 - 10 - scrollmenuh + 10)
            t = (y - 10 - scrollmenuh) / 80 + 1;
        l = ogp[t].l, h = ogp[t].h; //select base piece

        SDL_SetRenderDrawColor(renderer, col[t].r, col[t].g, col[t].b, col[t].a);
        clickMenu = 1;
        moves = 0;
    }
    else if (x <= offsetX + buttonWidth + 30) {
        if (offsetX > 0)offsetX = -80;
        else offsetX = 10;
        clickMenu = 1;
    }

    if (x >= 130 && x <= 230 && y >= maxy - 120)
        moves = 1 - moves, clickMenu = 1;
}

void text(SDL_Renderer* renderer, char t[100], int x, int y, int size) {
    TTF_Font* font = TTF_OpenFont("C:\\Electron\\Movistar Text Regular.ttf", size);
    SDL_Color color = { 255, 255, 255 };  // White

    const char* text = t;
    SDL_Surface* surface = TTF_RenderText_Solid(font, text, color);

    SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, surface);
    SDL_FreeSurface(surface);  // Free surface after creating texture


    SDL_Rect destRect = { x, y, strlen(t) * (size / 2), size * 2 };
    SDL_RenderCopy(renderer, texture, NULL, &destRect);
}

int inButton(int xb, int yb, int l, int h) {
    return x >= xb && x <= xb + l && y >= yb && y <= yb + h;
}

void drawMenu(SDL_Renderer* renderer) {
    int maxx, maxy;
    offsetY = scrollmenuh;
    char c2[] = "Save";
    char c1[] = "Load", c3[] = "Delete", c5[] = "Undo";
    SDL_GetRendererOutputSize(renderer, &maxx, &maxy);

    SDL_Rect bg = { 0, 0, offsetX + buttonWidth + 10 ,maxy };
    SDL_SetRenderDrawColor(renderer, col[0].r, col[0].g, col[0].b, col[0].a);
    SDL_RenderFillRect(renderer, &bg);
    SDL_Rect minimizer = { offsetX + buttonWidth + 10 , 0,  20, maxy };
    if (inButton(offsetX + buttonWidth + 10, 0, 20, maxy))
        SDL_SetRenderDrawColor(renderer, col[1].r, col[1].g, col[1].b, col[1].a);
    else
        SDL_SetRenderDrawColor(renderer, col[2].r, col[2].g, col[2].b, col[2].a);
    SDL_RenderFillRect(renderer, &minimizer);

    SDL_SetRenderDrawColor(renderer, col[0].r, col[0].g, col[0].b, col[0].a);
    SDL_RenderDrawLine(renderer, offsetX + buttonWidth + 30, 0, offsetX + buttonWidth + 30, maxy);
    int dir = (offsetX > 0) ? 1 : -1;
    for (int i = 0;i < 5;i++) {
        SDL_RenderDrawLine(renderer, offsetX + buttonWidth + 18 - 5 * dir + i, maxy / 2, offsetX + buttonWidth + 18 + 5 * dir + i, maxy / 2 - 30);
        SDL_RenderDrawLine(renderer, offsetX + buttonWidth + 18 - 5 * dir + i, maxy / 2, offsetX + buttonWidth + 18 + 5 * dir + i, maxy / 2 + 30);

    }

    int buttonTotalWidth = buttonWidth * 2 + spacing;  // Lățimea totală a celor două butoane + spațiu între ele
    int centerX = (maxx - buttonTotalWidth) / 2; // Poziția orizontală pentru butoane
    // Calculăm poziția Y pentru partea de jos a ferestrei
    int buttonY = maxy - (buttonHeight + 30);  // 30px distanță față de marginea de jos

    // Butonul Save
    saveButton = { centerX, buttonY, buttonWidth, buttonHeight };
    // Desenăm butonul Save
    loadButton = { centerX + buttonWidth + spacing, buttonY, buttonWidth, buttonHeight };
    sterge = { loadButton.x + buttonWidth + spacing, buttonY,buttonWidth,buttonHeight };
    reface = { sterge.x + buttonWidth + spacing, buttonY, buttonWidth,buttonHeight };
    if (inButton(centerX, buttonY, buttonWidth, buttonHeight))
        SDL_SetRenderDrawColor(renderer, col[1].r, col[1].g, col[1].b, col[1].a);
    else
        SDL_SetRenderDrawColor(renderer, col[2].r, col[2].g, col[2].b, col[2].a);
    SDL_RenderFillRect(renderer, &saveButton);
    SDL_SetRenderDrawColor(renderer, col[0].r, col[0].g, col[0].b, col[0].a);
    SDL_RenderDrawRect(renderer, &saveButton);
    text(renderer, c2, saveButton.x + (saveButton.w - strlen("Save") * (buttonHeight / 4)) / 2,
        saveButton.y + (saveButton.h - buttonHeight) / 2, buttonHeight / 2);  // Aliniere pe buton 


    if (inButton(centerX + buttonWidth + spacing, buttonY, buttonWidth, buttonHeight))
        SDL_SetRenderDrawColor(renderer, col[1].r, col[1].g, col[1].b, col[1].a);
    else
        SDL_SetRenderDrawColor(renderer, col[2].r, col[2].g, col[2].b, col[2].a);
    SDL_RenderFillRect(renderer, &loadButton);
    SDL_SetRenderDrawColor(renderer, col[0].r, col[0].g, col[0].b, col[0].a); // Contur negru
    SDL_RenderDrawRect(renderer, &loadButton);
    text(renderer, c1, loadButton.x + (loadButton.w - strlen("Load") * (buttonHeight / 4)) / 2,
        loadButton.y + (loadButton.h - buttonHeight) / 2, buttonHeight / 2);

    if (inButton(loadButton.x + buttonWidth + spacing, buttonY, buttonWidth, buttonHeight))
        SDL_SetRenderDrawColor(renderer, col[1].r, col[1].g, col[1].b, col[1].a);
    else
        SDL_SetRenderDrawColor(renderer, col[2].r, col[2].g, col[2].b, col[2].a);
    SDL_RenderFillRect(renderer, &sterge);
    SDL_SetRenderDrawColor(renderer, col[0].r, col[0].g, col[0].b, col[0].a);
    SDL_RenderDrawRect(renderer, &sterge);
    text(renderer, c3, sterge.x + (sterge.w - strlen("Delete") * (buttonHeight / 6)) / 2,
        sterge.y + (sterge.h - buttonHeight + 10), buttonHeight / 3);

    if (inButton(reface.x + spacing, buttonY, buttonWidth, buttonHeight))
        SDL_SetRenderDrawColor(renderer, col[1].r, col[1].g, col[1].b, col[1].a);
    else
        SDL_SetRenderDrawColor(renderer, col[2].r, col[2].g, col[2].b, col[2].a);
    SDL_RenderFillRect(renderer, &reface);
    SDL_SetRenderDrawColor(renderer, col[0].r, col[0].g, col[0].b, col[0].a);
    SDL_RenderDrawRect(renderer, &reface);
    text(renderer, c5, reface.x + (reface.w - strlen("Undo") * (buttonHeight / 4)) / 2,
        reface.y + (reface.h - buttonHeight) / 2, buttonHeight / 2);

    char c6[] = "Create";
    createRect= { centerX-buttonWidth-spacing, buttonY, buttonWidth, buttonHeight };
    if (inButton(createRect.x, buttonY, buttonWidth, buttonHeight))
        SDL_SetRenderDrawColor(renderer, col[1].r, col[1].g, col[1].b, col[1].a);
    else
        SDL_SetRenderDrawColor(renderer, col[2].r, col[2].g, col[2].b, col[2].a);
    SDL_RenderFillRect(renderer, &createRect);
    SDL_SetRenderDrawColor(renderer, col[0].r, col[0].g, col[0].b, col[0].a);
    SDL_RenderDrawRect(renderer, &createRect);
    text(renderer, c6, createRect.x + (createRect.w - strlen("Create") * (buttonHeight / 4)) / 2+18,
        createRect.y + (createRect.h - buttonHeight) / 2+7, buttonHeight / 2-12);


    SDL_Rect moveMenurect = { 130, maxy - 120, 100, 100 };
    if (moves)
        SDL_SetRenderDrawColor(renderer, col[1].r, col[1].g, col[1].b, col[1].a);
    else
        SDL_SetRenderDrawColor(renderer, col[2].r, col[2].g, col[2].b, col[2].a);
    SDL_RenderFillRect(renderer, &moveMenurect);
    SDL_SetRenderDrawColor(renderer, col[0].r, col[0].g, col[0].b, col[0].a);
    SDL_RenderDrawRect(renderer, &moveMenurect);
    char c4[7] = "Move";
    text(renderer, c4, 130, maxy - 130, 50);

    for (int i = 1; i <= tipuripiese; i++) {
        // Definim zona pentru buton
        SDL_Rect buttonRect = { offsetX, offsetY, buttonWidth, buttonHeight };

        // Desenează fundalul butonului
        SDL_SetRenderDrawColor(renderer, col[1].r, col[1].g, col[1].b, col[1].a); // Gri deschis
        SDL_RenderFillRect(renderer, &buttonRect);
        if (x >= offsetX && x <= offsetX + buttonWidth && y >= offsetY && y <= offsetY + buttonHeight) {
            SDL_SetRenderDrawColor(renderer, col[3].r, col[3].g, col[3].b, col[3].a); // Gri deschis
            SDL_RenderFillRect(renderer, &buttonRect);
        }

        // Desenează conturul butonului
        SDL_SetRenderDrawColor(renderer, col[0].r, col[0].g, col[0].b, col[0].a); // Negru
        SDL_RenderDrawRect(renderer, &buttonRect);

        // Scalează coordonatele pieselor
        float usableWidth = buttonWidth * 0.8f;  // 80% din dimensiunea butonului
        float usableHeight = buttonHeight * 0.8f;
        float scaleX = usableWidth / 7.0f;     // Normalizăm la 200x200
        float scaleY = usableHeight / 7.0f;
        float scale = fmin(scaleX, scaleY);      // Păstrăm proporțiile
        float centerX = buttonRect.x + buttonWidth / 2.0f;
        float centerY = buttonRect.y + buttonHeight / 2.0f;

        // Desenează linii
        for (int j = 0; j <= ptmenu[i].lin; j++) {
            float x1 = centerX + ptmenu[i].linie[j][0] * scale;
            float y1 = centerY + ptmenu[i].linie[j][1] * scale;
            float x2 = centerX + ptmenu[i].linie[j][2] * scale;
            float y2 = centerY + ptmenu[i].linie[j][3] * scale;
            desenareLinie(renderer, x1, y1, x2, y2, 1.0f);
            //if (i == 1) cout <<endl <<j << " ";
        }

        // Desenează cercuri
        for (int j = 0; j <= ptmenu[i].ce; j++) {
            float cx = centerX + ptmenu[i].cerc[j][0] * scale;
            float cy = centerY + ptmenu[i].cerc[j][1] * scale;
            float radius = ptmenu[i].cerc[j][2] * scale;
            desenareCerc(renderer, cx, cy, radius, radius, 1.0f);
        }

        // Desenează dreptunghiuri
        for (int j = 0; j <= ptmenu[i].r; j++) {
            float x = centerX + ptmenu[i].dr[j][0] * scale;
            float y = centerY + ptmenu[i].dr[j][1] * scale;
            float w = ptmenu[i].dr[j][2] * scale;
            float h = ptmenu[i].dr[j][3] * scale;
            SDL_Rect rect = { (int)x, (int)y, (int)w, (int)h };
            SDL_RenderDrawRect(renderer, &rect);
        }

        // Desenează arcuri
        for (int j = 0; j <= ptmenu[i].ar; j++) {
            float cx = centerX + ptmenu[i].arc[j][0] * scale;
            float cy = centerY + ptmenu[i].arc[j][1] * scale;
            float r1 = ptmenu[i].arc[j][2] * scale;
            float r2 = ptmenu[i].arc[j][3] * scale;
            desenareArc(renderer, cx, cy, r1, r2);
        }

        // Avansează la următorul buton
        offsetY += buttonHeight + spacing;

    }
}
float textToNumber(const char* text) {
    float numar = 0.0f;
    bool isNegative = false;
    bool decimalPointFound = false;
    float decimalFactor = 0.1f;

    for (int i = 0; text[i] != '\0'; ++i) {
        char c = text[i];

        if (c == '-' && i == 0) {
            isNegative = true;
            continue;
        }

        if (c == '.') {
            decimalPointFound = true;
            continue;
        }

        if (c >= '0' && c <= '9') {
            if (decimalPointFound) {
                numar += (c - '0') * decimalFactor;
                decimalFactor /= 10.0f;
            }
            else {
                numar = numar * 10 + (c - '0');
            }
        }
        else {
            break;
        }
    }

    if (isNegative) {
        numar = -numar;
    }

    return numar;
}

void cinText(SDL_Event& event, char* inputText, int maxLength) {
    if (event.type == SDL_KEYDOWN) {
        if (event.key.keysym.sym == SDLK_RETURN) {
            cout << textToNumber(inputText);
            cinning = 0;
        }
        else if (event.key.keysym.sym == SDLK_BACKSPACE && strlen(inputText) > 0) {
            //deletes last char
            inputText[strlen(inputText) - 1] = '\0';
        }
        else if (event.key.keysym.sym >= SDLK_SPACE && event.key.keysym.sym <= SDLK_z) {
            //inlocuit cu event.key.keysym.sym >= SDLK_SPACE && event.key.keysym.sym <= SDLK_z daca vrem si litere
            //event.key.keysym.sym >= SDLK_0 && event.key.keysym.sym <= SDLK_9 || event.key.keysym.sym == SDLK_PERIOD
            if (strlen(inputText) < maxLength - 1) {
                size_t len = strlen(inputText);
                inputText[len] = event.key.keysym.sym;
                if (event.key.keysym.mod & KMOD_SHIFT)
                    inputText[len] -= 32;
                inputText[len + 1] = '\0';
            }
        }
    }
}
void gradient(SDL_Renderer* renderer, SDL_Color c, int x, int y, int l, int h, int stdr, int tp) {
    float segm = 255.0 / l;
    float taper = float(h) / float(l) / 2.0 * tp;
    float percent;
    for (int i = 0;i <= l;i++) {
        //cout << i << " ";
        //cout << c.a - segm * i << " ";
        percent = float(i) / float(l);
        SDL_SetRenderDrawColor(renderer, c.r, c.g, c.b, c.a - segm * i);
        SDL_RenderDrawLine(renderer, x + stdr * i, y + i * taper * percent * percent, x + stdr * i, y + h - i * taper * percent * percent);
    }
}
void drawPieceMenu(SDL_Renderer* renderer, int& pm) {
    if (pm) {

        SDL_SetRenderDrawColor(renderer, col[0].r, col[0].g, col[0].b, col[0].a);
        SDL_Rect menup = { pmx, pmy, pml, pmh };
        SDL_RenderFillRect(renderer, &menup);

        SDL_SetRenderDrawColor(renderer, 214, 17, 40, 255);
        menup = { int(pmx + pml * 0.85), pmy, int(pml * 0.15) + 1, int(pml * 0.15) };
        //cout<<pmx<< " "<<pmy<< " "<<pmx+pml*0.9<< " "<<pmy+pmh*0.9<<endl;
        SDL_RenderFillRect(renderer, &menup);

        SDL_SetRenderDrawColor(renderer, col[2].r, col[2].g, col[2].b, col[2].a);
        menup = { pmx, pmy, int(pml * 0.85), int(pml * 0.15) };
        SDL_RenderFillRect(renderer, &menup);


        //va trb sa adaug text..alta librarie..

        char t[100];
        sprintf(t, "Piece: %d", pm);
        text(renderer, t, pmx, pmy, 20);

        strcpy(t, "Tip: ");
        strcat(t, ptmenu[p[pm].tip].nume);
        if (strlen(t) > 25)ch = 17;
        else ch = 20;
        text(renderer, t, pmx, pmy + 50, ch);
        ch = pmy + 45;
        if (strlen(t) > 25)ch -= 6;
        strcpy(t, "x");
        text(renderer, t, pmx + 0.85 * pml + 10, pmy - 20, 35);

        //for (int i = 0; i < ptmenu[j].nrpct; ++i)
          //  if (piesa.esteliber[i] == 0) {
        for (int i = 0;i < ptmenu[p[pm].tip].nrpct; i++) {
            sprintf(t, "Conexiunea %d: %s", i + 1, (p[pm].esteliber[i] == 0) ? "Liber" : "Ocupat");
            ch += 50; //current heigth
            if (inButton(pmx, ch, pml, 50)&& (p[pm].esteliber[i] != 0))
                gradient(renderer, col[2], pmx, ch-3, pml, 45, 1, 0);
            text(renderer, t, pmx, ch, 20);
            //cout << p[pm].esteliber[i] << " ";
        }
        ch += 50;

        if (cinning)
            gradient(renderer, col[2], pmx, ch + whichValue * 50 - 5, pml, 50, 1, 0);
        sprintf(t, "Voltage: %g", p[pm].value[0]);
        text(renderer, t, pmx, ch, 20);

        sprintf(t, "Current: %g", p[pm].value[1]);
        text(renderer, t, pmx, ch + 50, 20);

        sprintf(t, "Resistance: %g", p[pm].value[2]);
        text(renderer, t, pmx, ch + 100, 20);


        //cout << endl;
    }
}

int inPieceMenu() {
    if (x >= pmx && x <= pmx + pml && y >= pmy && y <= pmy + pmh) {
        if (x >= int(pmx + pml * 0.85) && y <= int(pmy + pml * 0.15))
            pm = 0;
        else if (x<int(pmx + pml * 0.85) && y <= int(pmy + pmh * 0.15))
            movepm = 1;
        else movepm = 0;
        cout << movepm;
        return 1;
    }
    return 0;
}

void drawConnectionPoints(SDL_Renderer* renderer, piesa& piesa) {
    // Setează culoarea mov pentru dreptunghiuri
    SDL_SetRenderDrawColor(renderer, col[1].r, col[1].g, col[1].b, col[1].a); // Mov
    // Desenăm dreptunghiuri la punctele de conexiune
    for (int i = 0; i < piesa.nrpct; ++i)
        if (piesa.esteliber[i] == 0) {

            float pointX = piesa.x + piesa.conexiuni[i].x * 15 + 2;
            float pointY = piesa.y + piesa.conexiuni[i].y * 15 + 3;


            SDL_Rect rect = { pointX - piesa.l / 8.75, pointY - piesa.h / 8.75, piesa.l / 8.75, piesa.h / 8.75 }; // Ajustăm pentru a plasa punctul în mijloc
            SDL_RenderFillRect(renderer, &rect);


        }
}

void drawPiece(SDL_Renderer* renderer, piesa piece) {

    //piese inserate
    SDL_Rect rect = { piece.x - piece.l / 2,piece.y - piece.h / 2,piece.l,piece.h };
    if (piece.a == 0)
    {
        SDL_SetRenderDrawColor(renderer, 255, 10, 10, 255);
        SDL_RenderFillRect(renderer, &rect);
    }
    else
    {
        SDL_SetRenderDrawColor(renderer, col[0].r, col[0].g, col[0].b, col[0].a); // Negru
        int  scale = 15;

        // Desenează linii
        for (int j = 0; j <= piece.lin; j++) {

            float x1 = piece.x + piece.linie[j][0] * scale;
            float y1 = piece.y + piece.linie[j][1] * scale;
            float x2 = piece.x + piece.linie[j][2] * scale;
            float y2 = piece.y + piece.linie[j][3] * scale;
            desenareLinie(renderer, x1, y1, x2, y2, 1.0f);
            //if (i == 1) cout <<endl <<j << " ";
        }

        // Desenează cercuri
        for (int j = 0; j <= piece.ce; j++) {
            float cx = piece.x + piece.cerc[j][0] * scale;
            float cy = piece.y + piece.cerc[j][1] * scale;
            float radius = piece.cerc[j][2] * scale;
            desenareCerc(renderer, cx, cy, radius, radius, 1.0f);
        }

        // Desenează dreptunghiuri
        for (int j = 0; j <= piece.r; j++) {
            float x = piece.x + piece.dr[j][0] * scale;
            float y1 = piece.y + piece.dr[j][1] * scale;
            float w = piece.dr[j][2] * scale;
            float h = piece.dr[j][3] * scale;
            SDL_Rect rect = { (int)x, (int)y1, (int)w, (int)h };
            SDL_RenderDrawRect(renderer, &rect);
        }



        drawConnectionPoints(renderer, piece);
    }




}
void citestePiese()
{
    int i, j;
    char c = 0;
    ifstream f("C:\\Electron.txt");
    if (!f.is_open()) {
        cout << "Nu s-a putut deschide fișierul!" << endl;

    }
    f >> tipuripiese;
    f.ignore(numeric_limits<streamsize>::max(), '\n');
    for (i = 1;i <= tipuripiese;i++)
    {

        f.get(ptmenu[i].nume, 200);
        f.ignore(numeric_limits<streamsize>::max(), '\n');
        f >> ptmenu[i].nrpct;
        f.ignore(numeric_limits<streamsize>::max(), '\n');
        for (j = 0;j < ptmenu[i].nrpct;j++)
        {
            f >> ptmenu[i].conexiuni[j].x >> ptmenu[i].conexiuni[j].y;
            f.ignore(numeric_limits<streamsize>::max(), '\n');

        }
        f >> ptmenu[i].nrLinii;
        f.ignore(numeric_limits<streamsize>::max(), '\n');
        for (j = 0;j < ptmenu[i].nrLinii;j++) {
            int k;
            f >> c;
            if (c == 'A')
            {
                ++ptmenu[i].ar;
                for (k = 0;k < 4;k++)
                    f >> ptmenu[i].arc[ptmenu[i].ar][k];
            }
            else if (c == 'L')
            {
                ++ptmenu[i].lin;  for (k = 0;k < 4;k++)
                    f >> ptmenu[i].linie[ptmenu[i].lin][k];
            }
            else if (c == 'O')
            {
                ++ptmenu[i].ce;
                for (k = 0;k < 4;k++)
                    f >> ptmenu[i].cerc[ptmenu[i].ce][k];
            }
            else if (c == 'R')
            {
                ++ptmenu[i].r;
                for (k = 0;k < 4;k++)
                    f >> ptmenu[i].dr[ptmenu[i].r][k];
            }
            f.ignore(numeric_limits<streamsize>::max(), '\n');

        }
        ogp[i] = ptmenu[i];
        ogp[i].l = ogp[i].h = 70;

    }

    f.close();



}
void createPiece(SDL_Renderer* renderer) {
    int i;
    p[k] = ogp[t];
    //p[k].nrLinii = ptmenu[t].nrLinii;
    p[k].x = x, p[k].y = y;
    p[k].l = 70, p[k].h = 70, p[k].tip = t;

    p[k++].ori = 0;
    for (i = 0;i < 3;i++)
        p[k - 1].esteliber[i] = 0;
    p[k - 1].a = p[k - 1].b = 1;
    drawPiece(renderer, p[k - 1]);
    undod[++u] = 1; //esteplin();

}

void deleteConnection(int i, int x, int pin) {
    cout << "jezz" << i;
    p[x].esteliber[pin]--;

    for (int j2 = i;j2 < k2;j2++)
        c[j2] = c[j2 + 1];

    k2--;
}

void deletePiece(int i) {
    int j;
    for (j = 1;j <= k2;j++)
    {
        if (c[j].p1 == i) {
            deleteConnection(j, c[j].p2, c[j].pin2);

            j--;
        }
        if (c[j].p2 == i)
        {
            deleteConnection(j, c[j].p1, c[j].pin1);
            j--;
        }


    }
    for (j = 1; j <= k2; ++j) {
        if (c[j].p1 > i) c[j].p1--;
        if (c[j].p2 > i) c[j].p2--;
    }
    for (j = i;j < k;j++)
        p[j] = p[j + 1];
    k--;
    pm = 0;


}

int inPiece() {

    //return which piece was clicked, 0 if no piece
    for (int i = 0;i < k;i++) {

        if (x > p[i].x - p[i].l / 2 && x < p[i].x + p[i].l / 2)
        {

            if (y > p[i].y - p[i].h / 2 && y < p[i].y + p[i].h / 2)
                return i;
        }
    }
    return 0;
}
void rotateValue(float& x, float& y, float cx, float cy, float angle) {

    float radians = angle * M_PI / 180.0f;

    float newx = cos(radians) * (x - 0) - sin(radians) * (y - 0);
    float newy = sin(radians) * (x - 0) + cos(radians) * (y - 0);

    x = newx;
    y = newy;
}

int rotateCheck(int i) {
    if (rot == 0)
        return 0;
    int cx, cy;

    cx = p[i].x + (p[i].l + 15) * cos((p[i].ori2 - 60) * M_PI / 180.0);
    cy = p[i].y + (p[i].l + 15) * sin((p[i].ori2 - 60) * M_PI / 180.0);
    //cout << cx << " " << cy << endl;
    if ((x - cx) * (x - cx) + (y - cy) * (y - cy) <= p[i].l / 10 * p[i].l / 10) {
        return 1;
    }
    return 0;
}

void rotatePiece(SDL_Renderer* renderer, int i) {
    if (rot) {

        //cout << rot2  <<" " <<rotateCheck(i)<< endl;
        SDL_SetRenderDrawColor(renderer, col[0].r, col[0].g, col[0].b, col[0].a);

        desenareCerc(renderer, p[i].x, p[i].y, p[i].l + 15, p[i].l + 15, 1);

        //p[i].ori= p[i].ori2;
        //p[i].ori2= (atan2(y - p[i].y, x - p[i].x)+45) * 180.0 / M_PI;
        //cout << angle << " " << angle2 << endl;
        //angle = angle2 - angle;
        //p[i].ori = angle - p[i].ori;
        //cout << angle << " "<< angle2 << endl;
        //cout << endl;
        desenareCerc(renderer, p[i].x + (p[i].l + 15) * cos((p[i].ori2 - 60) * M_PI / 180.0), p[i].y + (p[i].l + 15) * sin((p[i].ori2 - 60) * M_PI / 180.0), p[i].l / 7, p[i].l / 7, 1);

        rotateCheck(i);
        if (rot2) {
            if (undod[u] != 4 || undod[u - 1] != i) undod[++u] = i, undod[++u] = 4;
            p[i].ori = p[i].ori2;
            p[i].ori2 = (atan2(y - p[i].y, x - p[i].x) + 45) * 180.0 / M_PI;

            for (int j = 0; j < ptmenu[p[i].tip].nrLinii; j++) {
                //cout << p[i].linie[j][0] << " " << p[i].linie[j][1] << " " << p[i].linie[j][2] << " " << p[i].linie[j][3] << endl;
                rotateValue(p[i].linie[j][0], p[i].linie[j][1], p[i].x, p[i].y, p[i].ori2 - p[i].ori);
                rotateValue(p[i].linie[j][2], p[i].linie[j][3], p[i].x, p[i].y, p[i].ori2 - p[i].ori);
            }
            for (int j = 0;j < p[i].nrpct;j++) {
                rotateValue(p[i].conexiuni[j].x, p[i].conexiuni[j].y, p[i].x, p[i].y, p[i].ori2 - p[i].ori);
            }
            for (int j = 0;j <= p[i].ce;j++) {
                rotateValue(p[i].cerc[j][0], p[i].cerc[j][1], p[i].x, p[i].y, p[i].ori2 - p[i].ori);
            }
        }
    }
}
/*void rotationSnap(int i, int factor) {
    not sure if its worth fixing cand avem deja 360 grade
    //p[i].ori = int(p[i].ori2 / 90+factor) * 90;
    cout << p[i].ori << " " << p[i].ori2 << endl;

    for (int j = 0; j < ptmenu[p[i].tip].nrLinii; j++)
        for(int k=0;k<4;k++){
            //cout << p[i].linie[j][0] << " " << p[i].linie[j][1] << " " << p[i].linie[j][2] << " " << p[i].linie[j][3] << endl;
            p[i].linie[j][k] = ogp[p[i].tip].linie[j][k];
         }
    for (int j = 0;j < p[i].nrpct;j++) {
        p[i].conexiuni[j] = ogp[i].conexiuni[j];
    }
    //p[i].ori2 = p[i].ori + factor;
}*/



void movePiece(SDL_Renderer* renderer, SDL_Event event) {
    c[k2].p2 = 0;
    SDL_GetMouseState(&x, &y);
    int i = inPiece(), ok = 1, j;
    p[inPiece()].x += event.motion.xrel; // moves position
    p[inPiece()].y += event.motion.yrel;
    for (j = 1;j <= k && ok;j++)
        if (abs(p[j].x - p[i].x) < (p[j].l + p[i].l) / 2 && abs(p[j].y - p[i].y) < (p[j].l + p[i].l) / 2 && i != j)
        {
            p[i].a = 0;
            p[i].b = j;
            ok = 0;
        }
    if (ok)
    {
        p[i].a = 1;
        p[p[i].b].a = 1;
    }
}


void movePieceMenu(SDL_Renderer* renderer, SDL_Event event) {
    c[k2].p2 = 0;
    SDL_GetMouseState(&x, &y);

    pmx += event.motion.xrel; // moves position
    pmy += event.motion.yrel;
    //cout<<pmx<< " "<<pmy<<endl;
}

int inPunct(float mouseX, float mouseY, int& piesaselectata, int& pinselectat) {
    int i;
    for (i = 0;i < k;i++)
        for (int j = 0; j < ptmenu[p[i].tip].nrpct; j++) {

            float pointX = p[i].x + p[i].conexiuni[j].x * 15;
            float pointY = p[i].y + p[i].conexiuni[j].y * 15;
            float size = p[i].l / 5; // marimea punctului

            //  mouse ul este peste punct
            if (mouseX >= pointX - size && mouseX <= pointX + size &&
                mouseY >= pointY - size && mouseY <= pointY + size) {
                piesaselectata = i;
                pinselectat = j;
                return 1;
            }

        }

    return 0;
}
int sourcePiece = -1, targetPiece = -1, sourcePin = -1, targetPin = -1;

void dirVector(int& a, int& b) {
    //saves most important direction
    //if its more to the right than up then it will be right etc
    if (abs(a) > abs(b)) {
        a = (a > 0) - (a < 0);
        b = 0;
    }
    else {
        b = (b > 0) - (b < 0);
        a = 0;
    }
}

void drawConnect(SDL_Renderer* renderer, int i) {
    //black line between 2 pieces, to be changed later
    SDL_SetRenderDrawColor(renderer, col[0].r, col[0].g, col[0].b, col[0].a);
    //SDL_RenderDrawLine(renderer, p[c[i].p1].conexiuni[c[i].pin1].x + p[c[i].p1].x - p[c[i].p1].l / 2, p[c[i].p1].conexiuni[c[i].pin1].y + p[c[i].p1].y - p[c[i].p1].h / 2,
        //p[c[i].p2].conexiuni[c[i].pin2].x +p[c[i].p2].x -p[c[i].p2].l / 2, p[c[i].p2].conexiuni[c[i].pin2].y+p[c[i].p2].y - p[c[i].p2].h / 2);
    int x1 = p[c[i].p1].conexiuni[c[i].pin1].x * 15 + p[c[i].p1].x;// -p[c[i].p1].l / 2 - p[c[i].p1].l / 17;
    int y1 = p[c[i].p1].conexiuni[c[i].pin1].y * 15 + p[c[i].p1].y;// -p[c[i].p1].h / 2 - p[c[i].p1].h / 17;
    int x2 = p[c[i].p2].conexiuni[c[i].pin2].x * 15 + p[c[i].p2].x;// -p[c[i].p2].l / 2 - p[c[i].p1].l / 17;
    int y2 = p[c[i].p2].conexiuni[c[i].pin2].y * 15 + p[c[i].p2].y;// -p[c[i].p2].h / 2 - p[c[i].p1].h / 17;
    //cout << x1 << ' ' << y1 << " " << x2 << " " << y2 << endl;
    int leftright1, updown1, leftright2, updown2, lc;

    lc = abs(x2 - x1) / 3 + 10;

    //1 if right/up -1 if left/down
    leftright1 = x1 - p[c[i].p1].x;
    updown1 = y1 - p[c[i].p1].y;
    dirVector(leftright1, updown1);

    //small line to continue the direction
    SDL_RenderDrawLine(renderer, x1, y1, x1 + leftright1 * lc, y1 + updown1 * lc);
    x1 = x1 + leftright1 * lc, y1 = y1 + updown1 * lc; //updates where we are


    //same for second one
    leftright2 = x2 - p[c[i].p2].x;
    updown2 = y2 - p[c[i].p2].y;
    dirVector(leftright2, updown2);

    SDL_RenderDrawLine(renderer, x2, y2, x2 + leftright2 * lc, y2 + updown2 * lc);
    x2 = x2 + leftright2 * lc, y2 = y2 + updown2 * lc;
    //cout<<x1<< " "<<y1<< " "<<x2<< " "<<y2<<leftright1<< " "<<updown2<<endl;
    //390 214 267 3451 -1
    //787 416 609 439 1 0 -1 1
    if (leftright2 && leftright2 == -updown1 || (leftright1 == -leftright2 && leftright1 == -1) || x1 > x2)
        swap(x1, x2), swap(y1, y2), swap(leftright1, leftright2), swap(updown1, updown2);
    if (leftright1 == -1 && leftright1 == -updown2 && x1 < x2) {
        SDL_RenderDrawLine(renderer, x1, y1, x1, max(y2, y1 + lc));
        y1 = max(y2, y1 + lc);
    }
    if (leftright1 == 1 && leftright1 == -updown2 && x1 > x2 && y2 >= y1) {
        //SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
        SDL_RenderDrawLine(renderer, x1, y1, x1, max(y2, y1 + lc));
        y1 = max(y2, y1 + lc);
    }
    if (updown1 == 1 && updown1 == leftright2 && x1 > x2) {
        SDL_RenderDrawLine(renderer, x2, y2, x2, max(y1, y2 + lc));
        y2 = max(y1, y2 + lc);
        //cout<<x1<< " "<<y1<< " "<<x2<< " "<<y2<<leftright1<< " "<<updown2<<endl;
    }
    //cout<<x1<< " "<<y1<< " "<<x2<< " "<<y2<<leftright1<< " "<<updown2<<endl;
    if (updown2 == -1 && updown2 == leftright1 ) {
        SDL_RenderDrawLine(renderer, x1, y1, x1, y1 + lc);
        y1 = y1 + lc;
        //cout<<x1<< " "<<y1<< " "<<x2<< " "<<y2<<" "<<leftright1<< " "<<updown2<<endl;
    }

    //SDL_SetRenderDrawColor(renderer, 0, 255, 0, 255);
    if (updown1 != 0) {
        int aux;
        if (updown1 == 1) {
            aux = max(y1, y2);
        }
        else aux = min(y1, y2);
        SDL_RenderDrawLine(renderer, x1, y1, x1, aux);
        y1 = aux; //so that we get a rounder form if both are vertical
        SDL_RenderDrawLine(renderer, x1, y1, x1 + (x2 - x1) / 4, y1);
        x1 = x1 + (x2 - x1) / 4;
        leftright1 = -leftright2; //so that we get a less harsh connection if one is vertical the other horizontal
    }
    //same for second
    if (updown2 != 0) {
        int aux;
        if (updown2 == 1) {
            aux = max(y1, y2);
        }
        else aux = min(y1, y2);
        SDL_RenderDrawLine(renderer, x2, y2, x2, aux);
        y2 = aux;
        SDL_RenderDrawLine(renderer, x2, y2, x2 + (x1 - x2) / 4, y2);
        x2 = x2 + (x1 - x2) / 4;
        leftright2 = -leftright1;//working primarily horizontally
    }
    //SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    //cadranu 3 reparat
    if ((x1 > x2 && leftright2 == -1) || (x1 < x2 && leftright2 == 1) || updown1 == leftright2)
        swap(x1, x2), swap(y1, y2), swap(leftright1, leftright2), swap(updown1, updown2);
    //so we'll need less cases as x1 is the smaller one

    //SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
    //787 416 609 439 1 0 -1 1
    if (leftright1 * leftright2 < 0 && leftright1 == -1 && !updown2) {
        SDL_RenderDrawLine(renderer, x2, y2, x2, min(y2 - lc / 2, (y1 + y2 / 2)));
        y2 = min(y2 - lc / 2, (y1 + y2 / 2));
    }
    //SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);

    //cout<<x1<< " "<<y1<< " "<<x2<< " "<<y2<<" "<<leftright1<< " "<<updown1<< " "<<leftright2<< " "<<updown2<<endl;

    //750 274 566 338 1 0 -1 1
    //SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
    if (leftright1 * leftright2<0 && leftright2 == -1 && !updown1 && x1>x2) {
        //swap(x1, x2), swap(y1, y2), swap(leftright1, leftright2), swap(updown1, updown2);
        SDL_RenderDrawLine(renderer, x1, y1, x1, max((y1 + y2) / 2, y1 + lc / 2));
        y1 = max((y1 + y2) / 2, y1 + lc / 2);
        swap(x1, x2), swap(y1, y2), swap(leftright1, leftright2), swap(updown1, updown2);
    }
    //SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);

    //for the cases in which theyre going in opposite directions
    if (updown1 * updown2 < 0) {
        SDL_RenderDrawLine(renderer, x2, y2, x2 + (x1 - x2) / 3, y2);
        x2 = x2 + (x1 - x2) / 3;
    }
    //SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    //idk if the if else is necessary tbh
    if (x1 > x2 && leftright1 == updown2 == -1)
        swap(x1, x2), swap(y1, y2), swap(leftright1, leftright2), swap(updown1, updown2);
    if (updown1 && updown2) {
        SDL_RenderDrawLine(renderer, x1, y1, x2, y1);
        SDL_RenderDrawLine(renderer, x2, y1, x2, y2);
    }
    else {
        SDL_RenderDrawLine(renderer, x1, y1, x1, y2);
        SDL_RenderDrawLine(renderer, x1, y2, x2, y2);
    }
}
void connect(SDL_Renderer* renderer) {

    // Găsește piesa și pinul sursă
    if (targetPiece != -1 && targetPiece != sourcePiece || sourcePiece == -1) {
        sourcePiece = -1, targetPiece = -1, sourcePin = -1, targetPin = -1;

        if (!inPunct(x, y, sourcePiece, sourcePin)) {
            cout << "Nu s-a selectat un punct valid pentru conexiune." << endl;
            return;
        }
    }


    // Găsește piesa și pinul destinație
    if (!inPunct(x, y, targetPiece, targetPin) || sourcePiece == targetPiece) {
        cout << "Nu se poate realiza conexiunea." << sourcePiece << " " << targetPiece << endl;
        return;
    }



    // Creează conexiunea
    c[k2] = { sourcePiece, targetPiece, 0, sourcePin, targetPin };
    p[sourcePiece].esteliber[sourcePin]++;
    p[targetPiece].esteliber[targetPin]++;

    drawConnect(renderer, k2);
    undod[++u] = 2; //esteplin();
    k2++;

    cout << "Conexiune realizată între piesa " << sourcePiece << " și " << targetPiece << "." << endl;


}
void resizePiece(piesa& p, float factor) {
    p.l += factor * p.l;
    p.h += factor * p.h;
    for (int j = 0;j < p.nrLinii;j++) {
        p.linie[j][0] += factor * p.linie[j][0];
        p.linie[j][1] += factor * p.linie[j][1];
        p.linie[j][2] += factor * p.linie[j][2];
        p.linie[j][3] += factor * p.linie[j][3];


    }
    for (int j = 0;j <= p.ce;j++) {
        p.cerc[j][0] += factor * p.cerc[j][0];
        p.cerc[j][1] += factor * p.cerc[j][1];
        p.cerc[j][2] += factor * p.cerc[j][2];
        p.cerc[j][3] += factor * p.cerc[j][3];
    }
    for (int j = 0;j < p.nrpct;j++) {
        p.conexiuni[j].x += factor * p.conexiuni[j].x;
        p.conexiuni[j].y += factor * p.conexiuni[j].y;
    }
}
void resizePM(SDL_Renderer* renderer, int i) {
    if (rpm) {
        SDL_SetRenderDrawColor(renderer, col[2].r, col[2].g, col[2].b, col[2].a);
        desenareCerc(renderer, p[i].x - p[i].l / 1, p[i].y + p[i].h * 1.4, p[i].l / 4, p[i].l / 4, 1);
        desenareCerc(renderer, p[i].x + p[i].l / 1, p[i].y + p[i].h * 1.4, p[i].l / 4, p[i].l / 4, 1);

        for (int j = 0;j < 3;j++) {
            SDL_RenderDrawLine(renderer, p[i].x - p[i].l / 1.13, p[i].y + p[i].h * 1.4 + j - 2, p[i].x - p[i].l / 0.9, p[i].y + p[i].h * 1.4 + j - 2);
            SDL_RenderDrawLine(renderer, p[i].x + p[i].l / 1.13, p[i].y + p[i].h * 1.4 + j - 2, p[i].x + p[i].l / 0.9, p[i].y + p[i].h * 1.4 + j - 2);
            SDL_RenderDrawLine(renderer, p[i].x + p[i].l / 1 + j - 2, p[i].y + p[i].h * 1.28, p[i].x + p[i].l / 1 + j - 2, p[i].y + p[i].h * 1.5);
        }

    }
}
int resizeCheck(int i) {
    if ((x - (p[i].x - p[i].l / 1)) * (x - (p[i].x - p[i].l / 1)) +
        (y - (p[i].y + p[i].h * 1.4)) * (y - (p[i].y + p[i].h * 1.4)) <=
        (p[i].l / 4) * (p[i].l / 4)) {
        return -1;
    }

    else if ((x - (p[i].x + p[i].l / 1)) * (x - (p[i].x + p[i].l / 1)) +
        (y - (p[i].y + p[i].h * 1.4)) * (y - (p[i].y + p[i].h * 1.4)) <=
        (p[i].l / 4) * (p[i].l / 4)) {
        return 1;
    }

    return 0;
}

void moveScreen(SDL_Renderer* render, SDL_Event event) {
    SDL_GetMouseState(&x, &y);
    int i;
    for (i = 1;i < k;i++) {
        p[i].x += event.motion.xrel; // moves position
        p[i].y += event.motion.yrel;
    }
}

void zoomScreen(SDL_Renderer* renderer, float factor) {
    SDL_GetMouseState(&x, &y);
    int i;
    for (i = 1;i < k;i++) {
        resizePiece(p[i], factor);
        p[i].x += (p[i].x - x) * factor; // moves position
        p[i].y += (p[i].y - y) * factor;
        //p[i].l += p[i].l * zoom;
        //p[i].h += p[i].h * zoom;
    }
    for (i = 1;i <= tipuripiese;i++) {
        resizePiece(ogp[i], factor);
    }
    cout << ogp[0].l;

}

void themeChangeArrow(SDL_Renderer* renderer, int y, int h) {
    SDL_SetRenderDrawColor(renderer, col[2].r, col[2].g, col[2].b, col[2].a);
    y += 10;
    h *= 0.75;
    for (int i = 0;i < 10;i++) {
        SDL_RenderDrawLine(renderer, maxx / 2 - maxx / 6 + i, y, maxx / 2 - maxx / 6 - maxx / 20 + i, y + h / 2);
        SDL_RenderDrawLine(renderer, maxx / 2 - maxx / 6 + i, y + h, maxx / 2 - maxx / 6 - maxx / 20 + i, y + h / 2);

        SDL_RenderDrawLine(renderer, maxx / 2 + maxx / 6 + i, y, maxx / 2 + maxx / 6 + maxx / 20 + i, y + h / 2);
        SDL_RenderDrawLine(renderer, maxx / 2 + maxx / 6 + i, y + h, maxx / 2 + maxx / 6 + maxx / 20 + i, y + h / 2);
    }
}
void themeChange(int i) {
    col[0] = col[4 * i];
    col[1] = col[4 * i + 1];
    col[2] = col[4 * i + 2];
    col[3] = col[4 * i + 3];
}

SDL_Color highlightSelection(int yMM, int h) {
    if (y >= yMM && y <= yMM + h) {
        return col[1];
    }
    else return col[2];
}
void buttonMain(SDL_Renderer* renderer, SDL_Color c, int x, int y, int l, int h) {
    SDL_Rect button = { x - l / 2, y, l, h };
    c = highlightSelection(y, h);
    SDL_SetRenderDrawColor(renderer, c.r, c.g, c.b, c.a);
    SDL_RenderFillRect(renderer, &button);

    gradient(renderer, c, x + l / 2, y, l, h - 1, 1, 0);
    gradient(renderer, c, x - l / 2, y, l, h - 1, -1, 0);

}
void load() {
    OPENFILENAME ofn;
    wchar_t szFile[260];

    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = NULL;
    ofn.lpstrFile = szFile;
    ofn.lpstrFile[0] = L'\0';
    ofn.nMaxFile = sizeof(szFile) / sizeof(wchar_t);
    ofn.lpstrFilter = L"All Files\0*.*\0Text Files\0*.TXT\0";
    ofn.nFilterIndex = 1;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = L"C:\\";
    ofn.lpstrTitle = L"Open File";
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;

    if (GetOpenFileName(&ofn) == TRUE) {
        cout << "Fisier incarcat: " << endl;

        ifstream inFile(szFile, ios::binary);
        if (!inFile) {
            cout << "Eroare la deschiderea fișierului pentru încărcare!" << endl;
            return;
        }

        // Citește numărul de piese și conexiuni
        inFile.read(reinterpret_cast<char*>(&k), sizeof(k)); cout << "plang";
        inFile.read(reinterpret_cast<char*>(&k2), sizeof(k2));

        // Încarcă piesele și conexiunile direct în `p` și `c`
        inFile.read(reinterpret_cast<char*>(p), k * sizeof(piesa));
        inFile.read(reinterpret_cast<char*>(c), k2 * sizeof(conexiune));

        inFile.close();
        cout << k << " " << k2;

    }
}
void mainMenu(SDL_Renderer* renderer, SDL_Event event) {

    SDL_SetRenderDrawColor(renderer, col[0].r, col[0].g, col[0].b, col[0].a);
    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);

    SDL_RenderClear(renderer);
    char t[100];
    strcpy(t, "Electron");
    SDL_GetRendererOutputSize(renderer, &maxx, &maxy);
    int size = 80;

    text(renderer, t, maxx / 2 - strlen(t) / 2.0 * size / 2, maxy / 2 - size * 4, size);

    buttonMain(renderer, col[1], maxx / 2, maxy / 3, maxx / 3, maxy / 5);
    /*SDL_Rect button = {maxx / 3, maxy / 3, maxx / 3, maxy / 5};
    SDL_SetRenderDrawColor(renderer, col[1].r, col[1].g, col[1].b, col[1].a);
    SDL_RenderFillRect(renderer, &button);

    gradient(renderer, col[1], maxx / 3 * 2, maxy / 3, maxx / 4, maxy / 5-1, 1, 0);
    gradient(renderer, col[1], maxx / 3, maxy / 3, maxx / 4, maxy / 5 - 1, -1, 0);*/

    strcpy(t, "Start");
    size = 60;
    text(renderer, t, maxx / 2 - strlen(t) / 2 * size / 2 - 10, maxy / 2.8, size);

    buttonMain(renderer, col[2], maxx / 2, maxy / 1.72, maxx / 6, maxy / 12);
    strcpy(t, "Load");
    size = 40;
    text(renderer, t, maxx / 2 - strlen(t) / 2.0 * size / 2, maxy / 1.75, size);

    buttonMain(renderer, col[2], maxx / 2, maxy / 1.72 + maxy / 10, maxx / 6, maxy / 12);
    strcpy(t, "Theme");
    size = 40;
    text(renderer, t, maxx / 2 - strlen(t) / 2.0 * size / 2, maxy / 1.75 + maxy / 10, size);
    themeChangeArrow(renderer, maxy / 1.72 + maxy / 10, maxy / 12);

    buttonMain(renderer, col[2], maxx / 2, maxy / 1.72 + 2 * maxy / 10, maxx / 6, maxy / 12);
    strcpy(t, "Exit");
    size = 40;
    text(renderer, t, maxx / 2 - strlen(t) / 2.0 * size / 2, maxy / 1.75 + 2 * maxy / 10, size);

    if (event.type == SDL_MOUSEBUTTONDOWN) {
        if (y >= maxy / 3 && y <= maxy / 3 + maxy / 5)
            mm = 0;
        else if (y >= maxy / 1.72 && y <= maxy / 1.72 + maxy / 12) {
            load();
            mm = 0;
        }
        else if (y >= maxy / 1.72 + 2 * maxy / 10 && y <= maxy / 1.72 + 2 * maxy / 10 + maxy / 12) {
            mm = 0;
            running = 0;
        }
        else if (y >= maxy / 1.72 + maxy / 10 && y <= maxy / 1.72 + maxy / 10 + maxy / 12) {
            cout << theme;
            if (x < maxx / 2) {
                theme--;
                if (theme < 1) theme = 5;
            }
            else {
                theme++;
                if (theme > 5) theme = 1;
            }
            cout << theme;
            themeChange(theme);
        }
    }
    if (event.type == SDL_KEYDOWN && event.key.keysym.sym == SDLK_RETURN) {
        mm = 0;
    }

    if (event.type == SDL_QUIT) {
        mm = 0, running = 0;
    }
    SDL_RenderPresent(renderer);
}
float normalization(float x, float middle){
    return (x - middle) / 60;
}
float denormalization(float x, float middle) {
    return x * 60 + middle;
}

void createMenu(SDL_Renderer* renderer, SDL_Event event) {
    SDL_SetRenderDrawColor(renderer, col[0].r, col[0].g, col[0].b, col[0].a);
    SDL_RenderClear(renderer);
    int i;
    //cout << x << " " << y << endl;
    
    SDL_SetRenderDrawColor(renderer, col[2].r, col[2].g, col[2].b, col[2].a/2);
    for (i = 0;i <=maxx/4;i += 60) {
        SDL_RenderDrawLine(renderer, maxx/2-i, maxy/2-300, maxx / 2 - i, maxy / 2 + 300);
        SDL_RenderDrawLine(renderer, maxx / 2 + i, maxy / 2 - 300, maxx / 2 + i, maxy / 2 + 300);
    }
    for (i = 0;i <=maxx/4;i += 60) {
        SDL_RenderDrawLine(renderer, maxx/2-300, maxy/2-i, maxx / 2 + 300, maxy/2-i );
        SDL_RenderDrawLine(renderer, maxx / 2 - 300, maxy / 2 + i, maxx / 2 + 300, maxy / 2 + i);
    }

    SDL_SetRenderDrawColor(renderer, col[1].r, col[1].g, col[1].b, col[1].a);
    for (i = -1;i < 2;i++) {
        SDL_RenderDrawLine(renderer, maxx / 2 - 10, maxy / 2 + i, maxx / 2 + 10, maxy / 2 + i);
        SDL_RenderDrawLine(renderer, maxx / 2 + i, maxy / 2 - 10, maxx / 2 + i, maxy / 2 + 10);
    }

    char t[50];
    SDL_Rect button = { maxx/16-20, maxy/2-300, maxx/8+40, 50 };
    sprintf(t, "Snap to grid: %s", snap ? "ON" : "OFF");
    SDL_SetRenderDrawColor(renderer, col[2 - snap].r, col[2 - snap].g, col[2 - snap].b, col[2 - snap].a);
    SDL_RenderFillRect(renderer, &button);
    text(renderer, t, button.x+10, button.y, 20);

    SDL_Rect button2 = { maxx / 32, maxy / 2 - 300+button.h+70, maxx / 2-300-maxx/16, 70 };
    sprintf(t, "Add Segment");
    SDL_SetRenderDrawColor(renderer, col[2 - (drawType == 1)].r, col[2 - (drawType == 1)].g, col[2 - (drawType == 1)].b, col[2 - (drawType == 1)].a);
    SDL_RenderFillRect(renderer, &button2);
    text(renderer, t, button2.x + 20, button2.y, button2.h/2);

    SDL_Rect button3 = { maxx / 32, button2.y + button2.h + 20, maxx / 2 - 300 - maxx / 16, button2.h };
    sprintf(t, "Add Rectangle");
    SDL_SetRenderDrawColor(renderer, col[2 - (drawType == 2)].r, col[2 - (drawType == 2)].g, col[2 - (drawType == 2)].b, col[2 - (drawType == 2)].a);
    SDL_RenderFillRect(renderer, &button3);
    text(renderer, t, button3.x + 4, button3.y, button3.h/2);

    SDL_Rect button4 = { maxx / 32, button3.y + button2.h + 20, maxx / 2 - 300 - maxx / 16, button2.h };
    sprintf(t, "Add Circle");
    SDL_SetRenderDrawColor(renderer, col[2 - (drawType == 3)].r, col[2 - (drawType == 3)].g, col[2 - (drawType == 3)].b, col[2 - (drawType == 3)].a);
    SDL_RenderFillRect(renderer, &button4);
    text(renderer, t, button4.x + 30, button4.y, button4.h / 2);

    /*SDL_Rect button5 = {maxx / 32, button4.y + button2.h + 20, maxx / 2 - 300 - maxx / 16, button2.h};
    sprintf(t, "Add Arc");
    SDL_SetRenderDrawColor(renderer, col[2 - (drawType == 4)].r, col[2 - (drawType == 4)].g, col[2 - (drawType == 4)].b, col[2 - (drawType == 4)].a);
    SDL_RenderFillRect(renderer, &button5);
    text(renderer, t, button5.x + 50, button5.y, button5.h / 2);*/

    SDL_Rect button6 = { maxx / 32, button4.y + button2.h + 20, maxx / 2 - 300 - maxx / 16, button2.h };
    sprintf(t, "Add Connection Point");
    SDL_SetRenderDrawColor(renderer, col[2 - (drawType == 5)].r, col[2 - (drawType == 5)].g, col[2 - (drawType == 5)].b, col[2 - (drawType == 5)].a);
    SDL_RenderFillRect(renderer, &button6);
    text(renderer, t, button6.x + 10, button6.y+15, button6.h / 2-15);

    SDL_Rect buttonUndo = { maxx / 32, maxy / 2 + 300 - button2.h, 90, button2.h };
    sprintf(t, "Undo");
    SDL_SetRenderDrawColor(renderer, col[2-inButton(buttonUndo.x, buttonUndo.y, buttonUndo.w, buttonUndo.h)].r, col[2 - inButton(buttonUndo.x, buttonUndo.y, buttonUndo.w, buttonUndo.h)].g,
        col[2 - inButton(buttonUndo.x, buttonUndo.y, buttonUndo.w, buttonUndo.h)].b, col[2 - inButton(buttonUndo.x, buttonUndo.y, buttonUndo.w, buttonUndo.h)].a);
    SDL_RenderFillRect(renderer, &buttonUndo);
    text(renderer, t, buttonUndo.x + 8, buttonUndo.y + 2, buttonUndo.h / 2);

    SDL_Rect buttonRedo = { maxx / 32+90+45, maxy/2+300-button2.h, 90, button2.h };
    sprintf(t, "Redo");
    SDL_SetRenderDrawColor(renderer, col[2 - inButton(buttonRedo.x, buttonRedo.y, buttonRedo.w, buttonRedo.h)].r, col[2 - inButton(buttonRedo.x, buttonRedo.y, buttonRedo.w, buttonRedo.h)].g,
        col[2 - inButton(buttonRedo.x, buttonRedo.y, buttonRedo.w, buttonRedo.h)].b, col[2 - inButton(buttonRedo.x, buttonRedo.y, buttonRedo.w, buttonRedo.h)].a);
    SDL_RenderFillRect(renderer, &buttonRedo);
    text(renderer, t, buttonRedo.x + 8, buttonRedo.y + 2, buttonRedo.h / 2);

    SDL_Rect buttonSave = { maxx / 2, maxy / 2 + 300, 300, 70 };
    sprintf(t, "Save");
    gradient(renderer, col[2 - inButton(buttonSave.x-300, buttonSave.y, buttonSave.w+300, buttonSave.h)], buttonSave.x, buttonSave.y, buttonSave.w, buttonSave.h, 1, 0);
    gradient(renderer, col[2 - inButton(buttonSave.x-300, buttonSave.y, buttonSave.w+300, buttonSave.h)], buttonSave.x, buttonSave.y, buttonSave.w, buttonSave.h, -1, 0);
    text(renderer, t, buttonSave.x -50, buttonSave.y-15, buttonSave.h / 2+12);

    SDL_Rect buttonX = { 10, 10, 70, 50 };
    sprintf(t, "Back");
    SDL_SetRenderDrawColor(renderer, col[2].r, col[2].g, col[2].b, col[2].a);
    SDL_RenderFillRect(renderer, &buttonX);
    text(renderer, t, buttonX.x + 10, buttonX.y, buttonX.h / 2 );

    gradient(renderer, col[2-(cinning&&(whichValue==-1))], maxx / 2, maxy / 2 - 370, maxx / 4, 70, 1, 0);
    gradient(renderer, col[2- (cinning && (whichValue == -1))], maxx / 2, maxy / 2 - 370, maxx / 4, 70, -1, 0);

    gradient(renderer, col[2*(cinning && whichValue > -1)], maxx / 2 + maxx / 4+maxx/8, maxy / 2 - 60 + whichValue * 120, maxx / 8, 120, 1, 0);
    gradient(renderer, col[2 * (cinning && whichValue > -1)], maxx / 2 + maxx / 4 + maxx / 8, maxy / 2 - 60 + whichValue * 120, maxx / 8, 120, -1, 0);
    SDL_SetRenderDrawColor(renderer, col[2].r, col[2].g, col[2].b, col[2].a);
    for (i = 0;i <= 3;i++)
        SDL_RenderDrawLine(renderer, maxx / 2 + 300, maxy / 2 - 60 + i * 120, maxx, maxy / 2 - 60 + i * 120);


    sprintf(t, "Name: %s", newPiece.nume);
    text(renderer, t, maxx / 2 - strlen(t) / 2 * 20, maxy / 2 - 300 - 80, 40);

    strcpy(t, "Voltage");
    text(renderer, t, maxx / 2 + 300 + 100, maxy / 2-60, 30);
    sprintf(t, "%g", newPiece.value[0]);
    text(renderer, t, maxx / 2 + 300 + 150-strlen(t)*15/2, maxy / 2, 30);

    strcpy(t, "Current");
    text(renderer, t, maxx / 2 + 300 + 100, maxy / 2 + 60, 30);
    sprintf(t, "%g", newPiece.value[1]);
    text(renderer, t, maxx / 2 + 300 + 150 - strlen(t) * 15 / 2, maxy / 2+120, 30);

    strcpy(t, "Resistance");
    text(renderer, t, maxx / 2 + 300 + 80, maxy / 2 + 180, 30);
    sprintf(t, "%g", newPiece.value[2]);
    text(renderer, t, maxx / 2 + 300 + 150 - strlen(t) * 15 / 2, maxy / 2+240, 30);

    newPiece.x = maxx -maxx/8;
    newPiece.y = maxy / 2-200;
    newPiece.lin = (newk + 1) / 2 - 1;
    newPiece.nrLinii = newPiece.lin+1;
    newPiece.l = 100;
    newPiece.h = 100;
    newPiece.a = 1;

    SDL_SetRenderDrawColor(renderer, col[3].r, col[3].g, col[3].b, col[3].a);
    SDL_Rect newRect = { newPiece.x-100, newPiece.y-100, 200, 200 };
    SDL_RenderFillRect(renderer, &newRect);

    drawPiece(renderer, newPiece);

    SDL_SetRenderDrawColor(renderer, col[3].r, col[3].g, col[3].b, col[3].a);
    for (i = 0;i <newk;i+=2) {
        SDL_RenderDrawLine(renderer, denormalization(newPiece.linie[i/2][0],maxx/2),denormalization( newPiece.linie[i/2][1], maxy/2),
            denormalization(newPiece.linie[i / 2][2], maxx / 2), denormalization(newPiece.linie[i / 2][3], maxy / 2));
        //cout << newPiece.linie[i][0] << " " << newPiece.linie[i][1] << " " << newPiece.linie[i][2] << " " << newPiece.linie[i][3] << endl;
    }
    for (i = 0;i <= newPiece.r; i++) {
        SDL_Rect temp = { denormalization(newPiece.dr[i][0], maxx/2), denormalization( newPiece.dr[i][1], maxy/2), 
            newPiece.dr[i][2]*60, newPiece.dr[i][3]*60 };
        SDL_RenderDrawRect(renderer, &temp);
    }
    for (i = 0;i <= newPiece.ce; i++) {
        desenareCerc(renderer, denormalization(newPiece.cerc[i][0], maxx / 2), denormalization(newPiece.cerc[i][1], maxy / 2),
            newPiece.cerc[i][2] * 60, newPiece.cerc[i][2] * 60, 1);
    }
    SDL_SetRenderDrawColor(renderer, col[1].r, col[1].g, col[1].b, col[1].a);
    for (i = 0;i < newPiece.nrpct;i++) {
        newRect = { int(denormalization(newPiece.conexiuni[i].x, maxx / 2)-15),int(denormalization(newPiece.conexiuni[i].y, maxy / 2)-15) , 30, 30 };
        SDL_RenderFillRect(renderer, &newRect);
    }
    

    if (event.type == SDL_MOUSEBUTTONDOWN) {
        cinning = 0;
        if (inButton(maxx /2-300, maxy / 2-300, 600, 600)) {
            if (drawType == 1) {
                if (newk % 2 == 0) {
                    newPiece.linie[newk / 2][0] = normalization(x, maxx / 2);
                    newPiece.linie[newk / 2][1] = normalization(y, maxy / 2);
                    if (snap) {
                        newPiece.linie[newk / 2][0] = round(newPiece.linie[newk / 2][0]);
                        newPiece.linie[newk / 2][1] = round(newPiece.linie[newk / 2][1]);
                    }
                    newk++;
                }
                else {
                    newPiece.linie[newk / 2][2] = normalization(x, maxx / 2);
                    newPiece.linie[newk / 2][3] = normalization(y, maxy / 2);
                    if (snap) {
                        newPiece.linie[newk / 2][2] = round(newPiece.linie[newk / 2][2]);
                        newPiece.linie[newk / 2][3] = round(newPiece.linie[newk / 2][3]);
                    }
                    newk++;
                }
            }
            if (drawType == 2) {
                newCheck = 1 - newCheck;
                if (newCheck == 1) {
                    newPiece.r++; 
                    newPiece.dr[newPiece.r][0] = normalization(x, maxx/2);
                    newPiece.dr[newPiece.r][1] = normalization(y, maxy/2);
                    if (snap) {
                        newPiece.dr[newPiece.r][0] = round(newPiece.dr[newPiece.r][0]);
                        newPiece.dr[newPiece.r][1] = round(newPiece.dr[newPiece.r][1]);
                    }
                }
                else {
                    newPiece.dr[newPiece.r][2] = normalization(x, maxx / 2)- newPiece.dr[newPiece.r][0];
                    newPiece.dr[newPiece.r][3] = normalization(y, maxy / 2)- newPiece.dr[newPiece.r][1];
                    if (snap) {
                        newPiece.dr[newPiece.r][2] = round(newPiece.dr[newPiece.r][2]);
                        newPiece.dr[newPiece.r][3] = round(newPiece.dr[newPiece.r][3]);
                    }
                }
            }
            if (drawType == 3) {
                newCheck = 1 - newCheck;
                if (newCheck == 1) {
                    newPiece.ce++;
                    newPiece.cerc[newPiece.ce][0] = normalization(x, maxx / 2);
                    newPiece.cerc[newPiece.ce][1] = normalization(y, maxy / 2);
                    if (snap) {
                        newPiece.cerc[newPiece.ce][0] = round(newPiece.cerc[newPiece.ce][0]);
                        newPiece.cerc[newPiece.ce][1] = round(newPiece.cerc[newPiece.ce][1]);
                    }
                }
                else {
                    float x1, x2, y1, y2;
                    x1 = newPiece.cerc[newPiece.ce][0];
                    y1 = newPiece.cerc[newPiece.ce][1];
                    x2= normalization(x, maxx / 2);
                    y2= normalization(y, maxy / 2);
                    newPiece.cerc[newPiece.ce][2] = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
                    newPiece.cerc[newPiece.ce][3] = newPiece.cerc[newPiece.ce][2];
                    if (snap) {
                        newPiece.cerc[newPiece.ce][2] = round(newPiece.cerc[newPiece.ce][2]);
                        newPiece.cerc[newPiece.ce][3] = round(newPiece.cerc[newPiece.ce][3]);
                    }
                }
            }
            if (drawType == 5) {
                undov[undonr++] = drawType;
                newPiece.conexiuni[newPiece.nrpct].x = normalization(x, maxx / 2);
                newPiece.conexiuni[newPiece.nrpct].y = normalization(y, maxy / 2);
                if (snap) {
                    newPiece.conexiuni[newPiece.nrpct].x = round(newPiece.conexiuni[newPiece.nrpct].x);
                    newPiece.conexiuni[newPiece.nrpct].y = round(newPiece.conexiuni[newPiece.nrpct].y);
                }
                newPiece.nrpct++;
                cout << newPiece.conexiuni[1].x << " " << newPiece.conexiuni[1].y << endl;
            }
            undov[undonr++] = drawType;
        }
        if (inButton(buttonSave.x-300, buttonSave.y, buttonSave.w+300, buttonSave.h)) {
            while (newPiece.r>-1) {
                newPiece.linie[newPiece.nrLinii][0] = newPiece.dr[newPiece.r][0];
                newPiece.linie[newPiece.nrLinii][1] = newPiece.dr[newPiece.r][1];
                newPiece.linie[newPiece.nrLinii][2] = newPiece.dr[newPiece.r][0] + newPiece.dr[newPiece.r][2];
                newPiece.linie[newPiece.nrLinii][3] = newPiece.dr[newPiece.r][1] ;

                newPiece.nrLinii++;
                newPiece.lin++;
                newPiece.linie[newPiece.nrLinii][0] = newPiece.dr[newPiece.r][0];
                newPiece.linie[newPiece.nrLinii][1] = newPiece.dr[newPiece.r][1];
                newPiece.linie[newPiece.nrLinii][2] = newPiece.dr[newPiece.r][0];
                newPiece.linie[newPiece.nrLinii][3] = newPiece.dr[newPiece.r][1] + newPiece.dr[newPiece.r][3];

                newPiece.nrLinii++;
                newPiece.lin++;
                newPiece.linie[newPiece.nrLinii][0] = newPiece.dr[newPiece.r][0] + newPiece.dr[newPiece.r][2];
                newPiece.linie[newPiece.nrLinii][1] = newPiece.dr[newPiece.r][1];
                newPiece.linie[newPiece.nrLinii][2] = newPiece.dr[newPiece.r][0] + newPiece.dr[newPiece.r][2];
                newPiece.linie[newPiece.nrLinii][3] = newPiece.dr[newPiece.r][1] + newPiece.dr[newPiece.r][3];

                newPiece.nrLinii++;
                newPiece.lin++;
                newPiece.linie[newPiece.nrLinii][0] = newPiece.dr[newPiece.r][0];
                newPiece.linie[newPiece.nrLinii][1] = newPiece.dr[newPiece.r][1] + newPiece.dr[newPiece.r][3];
                newPiece.linie[newPiece.nrLinii][2] = newPiece.dr[newPiece.r][0] + newPiece.dr[newPiece.r][2];
                newPiece.linie[newPiece.nrLinii][3] = newPiece.dr[newPiece.r][1] + newPiece.dr[newPiece.r][3];
                
                newPiece.nrLinii++;
                newPiece.lin++;
                newPiece.r--;
            }
            ptmenu[++tipuripiese] = newPiece;
            ogp[tipuripiese] = newPiece;
            cm = 0;
            running = 1;
        }
        if (inButton(button.x, button.y, button.w, button.h)) {
            snap = 1 - snap;
        }
        else if (inButton(button2.x, button2.y, button2.w, button2.h)) {
            drawType = 1;
        }
        else if (inButton(button3.x, button3.y, button3.w, button3.h)) {
            drawType = 2; newCheck = 0;
        }
        else if (inButton(button4.x, button4.y, button4.w, button4.h)) {
            drawType = 3; newCheck = 0;
        }
        /*else if (inButton(button5.x, button5.y, button5.w, button5.h)) {
            drawType = 4; newCheck = 0;
        }*/
        else if (inButton(button6.x, button6.y, button6.w, button6.h)) {
            drawType = 5;
        }
        else if (inButton(maxx / 4, maxy / 2 - 370, maxx / 2, 70)) {
            strcpy(newPiece.nume, "");
            cinning = 1; whichValue = -1;
        }
        else if (inButton(maxx / 2 + 350, maxy / 2 - 60, 200, 360)) {
            whichValue = (y-(maxy/2-60))/120;
            strcpy(textcin, "");
            cinning = 1;
        }
        else if (inButton(buttonUndo.x, buttonUndo.y, buttonUndo.w, buttonUndo.h)&&undonr>=0) {
            undonr -= 2; undocount++;
            if (undov[undonr] == 1)newk -= 2;
            else if (undov[undonr] == 2)newPiece.r--;
            else if (undov[undonr] == 3)newPiece.ce--;
            else if (undov[undonr] == 5)newPiece.nrpct--;
        }
        else if (inButton(buttonRedo.x, buttonRedo.y, buttonRedo.w, buttonRedo.h)&&undocount) {
            undocount--;
            if (undov[undonr] == 1)newk += 2;
            else if (undov[undonr] == 2)newPiece.r++;
            else if (undov[undonr] == 3)newPiece.ce++;
            else if (undov[undonr] == 5)newPiece.nrpct++;
            undonr += 2;
        }
        else if (inButton(buttonX.x, buttonX.y, buttonX.w, buttonX.h)) {
            cm = 0;
            running = 1;
        }

        //cout << normalization(x,maxx/2) << " " << normalization(y,maxy/2) << endl;
        
    }
    
    if (newk % 2) {
        newPiece.linie[newk / 2][2] = normalization(x, maxx / 2);
        newPiece.linie[newk / 2][3] = normalization(y, maxy / 2);
    }
    if (newCheck == 1&&drawType==2) {
        newPiece.dr[newPiece.r][2] = normalization(x, maxx / 2) - newPiece.dr[newPiece.r][0];
        newPiece.dr[newPiece.r][3] = normalization(y, maxy / 2) - newPiece.dr[newPiece.r][1];
    }
    else if (newCheck == 1 && drawType == 3) {
        float x1, x2, y1, y2;
        x1 = newPiece.cerc[newPiece.ce][0];
        y1 = newPiece.cerc[newPiece.ce][1];
        x2 = normalization(x, maxx / 2);
        y2 = normalization(y, maxy / 2);
        newPiece.cerc[newPiece.ce][2] = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        newPiece.cerc[newPiece.ce][3] = newPiece.cerc[newPiece.ce][2];
    }
    if (cinning) {
        if (whichValue == -1)
            cinText(event, newPiece.nume, 50);
        else {
            cinText(event, textcin, 20);
            newPiece.value[whichValue] = textToNumber(textcin);
        }
    }
    if (event.type == SDL_QUIT) {
        cm = 0, running = 0;
    }
    SDL_RenderPresent(renderer);
}



void drawLine(SDL_Renderer* renderer) {
    //no use for testing only
    SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
    SDL_RenderDrawLine(renderer, 200, 100, 700, 500);
}


void redrawAll(SDL_Renderer* renderer) {
    int i;
    SDL_SetRenderDrawColor(renderer, col[3].r, col[3].g, col[3].b, col[3].a);
    SDL_RenderClear(renderer);
    //drawMenu(renderer);
    for (i = 1;i < k;i++) {
        drawPiece(renderer, p[i]);
    }
    for (i = 1;i < k2;i++) {
        drawConnect(renderer, i);
    }

    rotatePiece(renderer, rot);
    resizePM(renderer, rpm);
    drawMenu(renderer);
    drawPieceMenu(renderer, pm);
    SDL_RenderPresent(renderer);
}


void deleteAll() {
    meow = k;ham = k2; undod[++u] = 3; //esteplin();
    k = 1; k2 = 1;
    rot = 0, rpm = 0;
}
void un() {
    cout << undod[u] << " ";
    if (undod[u] == 1) k--;
    else if (undod[u] == 2) k2--, p[c[k2].p1].esteliber[c[k2].pin1]--, p[c[k2].p2].esteliber[c[k2].pin2]--;
    else if (undod[u] == 3) k = meow, k2 = ham;
    else if (undod[u] == 4)
    {
        u--;
        for (int i = 0;i <= p[undod[u]].lin;i++)
            for (int j = 0;j < 4;j++)
                p[undod[u]].linie[i][j] = ptmenu[p[undod[u]].tip].linie[i][j];
        for (int i = 0;i < p[undod[u]].nrpct;i++)
            p[undod[u]].conexiuni[i] = ptmenu[p[undod[u]].tip].conexiuni[i];
        p[undod[u]].ori = 0;
    }
    u--;
    rot = 0, rpm = 0;
}

void save() {
    OPENFILENAME ofn;
    wchar_t szFile[260];

    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = NULL;
    ofn.lpstrFile = szFile;
    ofn.lpstrFile[0] = L'\0';
    ofn.nMaxFile = sizeof(szFile) / sizeof(wchar_t);
    ofn.lpstrFilter = L"All Files\0*.*\0Text Files\0*.TXT\0";
    ofn.nFilterIndex = 1;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = L"C:\\";
    ofn.lpstrTitle = L"Save As";
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_OVERWRITEPROMPT;

    if (GetSaveFileName(&ofn) == TRUE) {
        wcout << L"Fișier salvat ca: " << szFile << endl;

        ofstream outFile(szFile, ios::binary);
        if (!outFile) {
            cerr << "Eroare la deschiderea fișierului pentru salvare!" << endl;
            return;
        }

        // Salvează numărul de piese și conexiuni
        outFile.write(reinterpret_cast<char*>(&k), sizeof(k));  // Numărul de piese
        outFile.write(reinterpret_cast<char*>(&k2), sizeof(k2)); // Numărul de conexiuni

        // Salvează piesele și conexiunile
        outFile.write(reinterpret_cast<char*>(p), k * sizeof(piesa));        // Tabloul `p`
        outFile.write(reinterpret_cast<char*>(c), k2 * sizeof(conexiune));  // Tabloul `c`

        outFile.close();
    }
}


int main() {

    if (SDL_Init(SDL_INIT_VIDEO) != 0) {
        std::cout << "SDL_Init failed: " << SDL_GetError() << std::endl;
        return 1;
    }

    if (TTF_Init() == -1) {
        std::cout << "TTF_Init failed: " << TTF_GetError() << std::endl;
        SDL_Quit();
        return 1;
    }
    //TTF_Font* font = TTF_OpenFont("C:\\Electron\\Movistar Text Regular.ttf", 20);

    //create window
    SDL_Init(SDL_INIT_VIDEO);
    SDL_Window* window = SDL_CreateWindow("Electron", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 1200, 800, 0);

    //create renderer NOT the same thing as window
    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
    SDL_Event event;
    SDL_SetRenderDrawColor(renderer, 30, 20, 80, 255);
    SDL_RenderClear(renderer);

    int movep = 0, current;
    //int running = 1;
    while (mm) {
        while (SDL_PollEvent(&event)) {
            mainMenu(renderer, event);
            SDL_GetMouseState(&x, &y);
        }
    }

    //set bg color (r g b values)

    citestePiese();
    //drawMenu(renderer);
    //SDL_RenderPresent(renderer);
    
    //start main loop
mainloop:
    while (running) {
        //here add events= things that happen
        while (SDL_PollEvent(&event)) {
            SDL_GetMouseState(&x, &y);
            //when click
            if (event.type == SDL_MOUSEBUTTONDOWN) {
                //takes mouse position in x y
                SDL_GetMouseState(&x, &y);
                // Verifică dacă click-ul a fost pe butonul Save
                if (x >= saveButton.x && x <= saveButton.x + saveButton.w &&
                    y >= saveButton.y && y <= saveButton.y + saveButton.h) {
                    save(); inbottommenu = 1;
                }

                // Verifică dacă click-ul a fost pe butonul Load
                else if (x >= loadButton.x && x <= loadButton.x + loadButton.w &&
                    y >= loadButton.y && y <= loadButton.y + loadButton.h) {
                    load(); inbottommenu = 1;
                }

                else if (x >= sterge.x && x <= sterge.x + sterge.w &&
                    y >= sterge.y && y <= sterge.y + sterge.h) {
                    deleteAll(); inbottommenu = 1;
                }
                else if (x >= reface.x && x <= reface.x + reface.w &&
                    y >= reface.y && y <= reface.y + reface.h) {
                    un(); inbottommenu = 1;
                }
                else if (x >= createRect.x && x <= createRect.x + createRect.w &&
                    y >= createRect.y && y <= createRect.y + createRect.h) {
                    cm = 1; inbottommenu = 1; newk = 0;
                    newPiece = ogp[tipuripiese + 1];
                    running = 0;
                }
                else inbottommenu = 0;


                cout << inPiece(); //de verificare
                current = inPiece();

                if (event.button.button == SDL_BUTTON_RIGHT)
                    c[k2].p2 = 0;//dam cancel la conexiune

                connect(renderer); //wont do anything if we dont connect
                //can connect while moving maybe good maybe bad

                if (moves)moves2 = 1;//otherwise will move the screen infinitely
                else moves2 = 0;

                if (event.button.clicks == 2 && inPiece()) {
                    pm = inPiece();
                    pmx = maxx - 250, pmy = maxy - 400 - 50 * (p[pm].nrpct - 3), pml = 250, pmh = 400 + 50 * (p[pm].nrpct - 3);

                }
                if (!inPiece() && !inPieceMenu()) pm = 0;

                if (inPiece()) {
                    rot = rpm = inPiece();
                }
                if (rot && rotateCheck(rot)) {
                    rot2 = rotateCheck(rot);
                }


                menu(renderer); //checks if menu was pressed
                if (!clickMenu && !inPieceMenu() && !rotateCheck(rot) && resizeCheck(rpm) == 0 && !inbottommenu) {
                    if (!inPiece() && !moves && !inPunct(x, y, targetPiece, targetPin))createPiece(renderer); //draws if nothing else
                    else movep = 1;
                }
                if (event.button.button == SDL_BUTTON_RIGHT && inPiece())
                    deletePiece(inPiece());
                if (rpm && resizeCheck(rpm)) {
                    resizePiece(p[rpm], 0.1 * resizeCheck(rpm));
                }

                if (inButton(pmx, ch, pml, 150) && pm) {
                    strcpy(textcin, "");
                    cinning = 1; cinPiece = pm;
                    whichValue = (y - ch) / 50;
                }
                if (cinPiece != pm)cinning = 0;
            }
            if (cinning) {
                gradient(renderer, col[2], pmx, ch + whichValue * 50, pml, 50, 1, 0);
                cinText(event, textcin, 255);
                p[cinPiece].value[whichValue] = textToNumber(textcin);
            }

            if (x < offsetX + buttonWidth + 30 && event.type == SDL_MOUSEWHEEL) {
                scrollmenuh += event.wheel.y * 5;
                if (scrollmenuh > 10)scrollmenuh = 10;
                if (scrollmenuh < -(buttonHeight + spacing) * tipuripiese + maxy)scrollmenuh = -(buttonHeight + spacing) * tipuripiese + maxy;
            }

            if (inPiece() && event.type == SDL_MOUSEMOTION && movep && !moves2) {
                movePiece(renderer, event);
                if (p[inPiece()].a == 1)premovex = x, premovey = y;

            }

            if (movepm) {
                movePieceMenu(renderer, event);
            }

            if (event.type == SDL_MOUSEMOTION && moves2)
                moveScreen(renderer, event);

            if (event.type == SDL_MOUSEBUTTONUP) {
                int aux = inPiece();
                if (p[inPiece()].a == 0)p[aux].x = premovex, p[aux].y = premovey, p[aux].a = 1;
                movep = 0, moves2 = 0, movepm = 0, rot2 = 0;//stops moving
            }


            //when key press
            //resize also maybe move in void somehow??
            if (event.type == SDL_KEYDOWN) {
                if (event.key.keysym.sym == SDLK_RIGHT && current) {
                    resizePiece(p[current], 0.1);
                }
                if (event.key.keysym.sym == SDLK_LEFT && current) {
                    resizePiece(p[current], -0.1);
                }
                if (event.key.keysym.sym == SDLK_RIGHT && moves) {
                    zoomScreen(renderer, 0.1);
                }
                if (event.key.keysym.sym == SDLK_LEFT && moves) {
                    zoomScreen(renderer, -0.1);
                }
                if (event.key.keysym.sym == SDLK_c) {
                    cm = 1; newk = 0;
                    newPiece = ogp[tipuripiese + 1];
                    running = 0;
                }
                c[k2].p2 = 0;//dam cancel la conexiune
            }

            //when close window = ends main while
            if (event.type == SDL_QUIT) {
                running = 0;
            }
            redrawAll(renderer);
        }
        //resets color after connection turns it white
        SDL_SetRenderDrawColor(renderer, col[t].r, col[t].g, col[t].b, col[t].a);
        //updates screen on every frame = for now NOT necessary but who knows
        //SDL_RenderPresent(renderer);
    }
    while (cm) {
        while (SDL_PollEvent(&event)) {
            createMenu(renderer, event);
            SDL_GetMouseState(&x, &y);
            if (cm == 0) {
                goto mainloop;
            }
        }
    }
    return 0;
}
